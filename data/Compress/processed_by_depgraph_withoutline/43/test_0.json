{
    "bug_id": 43,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries",
    "test_body": "135: public void doesntWriteDataDescriptorWhenAddingRawEntries() throws IOException {\n136: ByteArrayOutputStream init = new ByteArrayOutputStream();\n137: try (ZipArchiveOutputStream zos = new ZipArchiveOutputStream(init)) {\n138: zos.putArchiveEntry(new ZipArchiveEntry(\"test1.txt\"));\n139: zos.write(\"foo\".getBytes(\"UTF-8\"));\n140: zos.closeArchiveEntry();\n141: }\n142: 143: File f = new File(dir, \"test.zip\");\n144: try (FileOutputStream fos = new FileOutputStream(f)) {\n145: fos.write(init.toByteArray());\n146: }\n147: 148: ByteArrayOutputStream o = new ByteArrayOutputStream();\n149: ZipArchiveEntry zae;\n150: try (ZipFile zf = new ZipFile(f);\n151: ZipArchiveOutputStream zos = new ZipArchiveOutputStream(o)) {\n152: zae = zf.getEntry(\"test1.txt\");\n153: zos.addRawArchiveEntry(zae, zf.getRawInputStream(zae));\n154: }\n155: 156: byte[] data = o.toByteArray();\n157: byte[] versionInLFH = Arrays.copyOfRange(data, 4, 6);\n158: // still 2.0 because of Deflate\n159: assertArrayEquals(new byte[] { 20, 0 }, versionInLFH);\n160: byte[] gpbInLFH = Arrays.copyOfRange(data, 6, 8);\n161: // no DD but EFS flag\n162: assertArrayEquals(new byte[] { 0, 8 }, gpbInLFH);\n163: 164: int cdhStart = findCentralDirectory(data);\n165: byte[] versionInCDH = Arrays.copyOfRange(data, cdhStart + 6, cdhStart + 8);\n166: assertArrayEquals(new byte[] { 20, 0 }, versionInCDH);\n167: byte[] gpbInCDH = Arrays.copyOfRange(data, cdhStart + 8, cdhStart + 10);\n168: assertArrayEquals(new byte[] { 0, 8 }, gpbInCDH);\n169: 170: int ddStart = cdhStart - 16;\n171: assertNotEquals(ZipLong.DD_SIG, new ZipLong(data, ddStart));\n172: long crcFromLFH = ZipLong.getValue(data, 14);\n173: long cSizeFromLFH = ZipLong.getValue(data, 18);\n174: long sizeFromLFH = ZipLong.getValue(data, 22);\n175: assertEquals(3, sizeFromLFH);\n176: 177: long crcFromCDH = ZipLong.getValue(data, cdhStart + 16);\n178: assertEquals(crcFromLFH, crcFromCDH);\n179: long cSizeFromCDH = ZipLong.getValue(data, cdhStart + 20);\n180: assertEquals(cSizeFromLFH, cSizeFromCDH);\n181: long sizeFromCDH = ZipLong.getValue(data, cdhStart + 24);\n182: assertEquals(sizeFromLFH, sizeFromCDH);\n183: }\n",
    "stack_trace": "junit.framework.AssertionFailedError: arrays first differed at element [0]; expected:<0> but was:<8>\nat org.junit.internal.ComparisonCriteria.arrayEquals(ComparisonCriteria.java:50)\nat org.junit.Assert.internalArrayEquals(Assert.java:473)\nat org.junit.Assert.assertArrayEquals(Assert.java:294)\nat org.junit.Assert.assertArrayEquals(Assert.java:305)\nat org.apache.commons.compress.archivers.zip.DataDescriptorTest.doesntWriteDataDescriptorWhenAddingRawEntries(DataDescriptorTest.java:162)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:copyFromZipInputStream(Ljava/io/InputStream;)V",
            "method_body": "private void copyFromZipInputStream(final InputStream src) throws IOException {\nif (entry == null) {\nZipUtil.checkRequestedFeatures(entry.entry);\nentry.hasWritten = true;\nwhile ((length = src.read(copyBuffer)) >= 0 )\nstreamCompressor.writeCounted(copyBuffer, 0, length);\ncount( length );\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
            "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate int alignment = 0;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nprivate static final ZipExtraField[] noExtraFields = new ZipExtraField[0];\nprivate long localHeaderOffset = OFFSET_UNKNOWN;\nprivate long dataOffset = OFFSET_UNKNOWN;\nprivate boolean isStreamContiguous = false;\nsuper(name);\nsetName(name);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeCopiedEntry(Z)V",
            "method_body": "private void closeCopiedEntry(final boolean phased) throws IOException {\npreClose();\nentry.bytesRead = entry.entry.getSize();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = checkIfNeedsZip64(effectiveMode);\ncloseEntry(actuallyNeedsZip64, phased);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "public ZipArchiveEntry(final ZipArchiveEntry entry) throws ZipException {\nthis((java.util.zip.ZipEntry) entry);\nsetInternalAttributes(entry.getInternalAttributes());\nsetExternalAttributes(entry.getExternalAttributes());\nsetExtraFields(getAllExtraFieldsNoCopy());\nsetPlatform(entry.getPlatform());\nfinal GeneralPurposeBit other = entry.getGeneralPurposeBit();\nsetGeneralPurposeBit(other == null ? null :\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;ZZJ)[B",
            "method_body": "private byte[] createLocalFileHeader(final ZipArchiveEntry ze, final ByteBuffer name, final boolean encodable,\nResourceAlignmentExtraField oldAlignmentEx =\nif (oldAlignmentEx != null) {\nint alignment = ze.getAlignment();\nif (alignment <= 0 && oldAlignmentEx != null) {\nif (alignment > 1 || (oldAlignmentEx != null && !oldAlignmentEx.allowMethodChange())) {\nfinal byte[] extra = ze.getLocalFileDataExtra();\nfinal int nameLen = name.limit() - name.position();\nfinal int len = LFH_FILENAME_OFFSET + nameLen + extra.length;\nfinal byte[] buf = new byte[len];\nSystem.arraycopy(LFH_SIG,  0, buf, LFH_SIG_OFFSET, WORD);\nfinal int zipMethod = ze.getMethod();\nfinal boolean dataDescriptor = usesDataDescriptor(zipMethod);\nputShort(versionNeededToExtract(zipMethod, hasZip64Extra(ze), dataDescriptor), buf, LFH_VERSION_NEEDED_OFFSET);\nfinal GeneralPurposeBit generalPurposeBit = getGeneralPurposeBits(!encodable && fallbackToUTF8, dataDescriptor);\ngeneralPurposeBit.encode(buf, LFH_GPB_OFFSET);\nputShort(zipMethod, buf, LFH_METHOD_OFFSET);\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, LFH_TIME_OFFSET);\nif (phased){\nputLong(ze.getCrc(), buf, LFH_CRC_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_CRC_OFFSET, WORD);\nif (hasZip64Extra(entry.entry)){\n} else if (phased) {\nputLong(ze.getCompressedSize(), buf, LFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, LFH_ORIGINAL_SIZE_OFFSET);\n} else if (zipMethod == DEFLATED || channel != null) {\nSystem.arraycopy(LZERO, 0, buf, LFH_COMPRESSED_SIZE_OFFSET, WORD);\nSystem.arraycopy(LZERO, 0, buf, LFH_ORIGINAL_SIZE_OFFSET, WORD);\nputShort(nameLen, buf, LFH_FILENAME_LENGTH_OFFSET);\nputShort(extra.length, buf, LFH_EXTRA_LENGTH_OFFSET);\nSystem.arraycopy( name.array(), name.arrayOffset(), buf, LFH_FILENAME_OFFSET, nameLen);\nSystem.arraycopy(extra, 0, buf, LFH_FILENAME_OFFSET + nameLen, extra.length);\nreturn buf;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getRawInputStream(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/io/InputStream;",
            "method_body": "public InputStream getRawInputStream(final ZipArchiveEntry ze) {\nif (!(ze instanceof Entry)) {\nfinal long start = ze.getDataOffset();\nreturn createBoundedInputStream(start, ze.getCompressedSize());\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:addRawArchiveEntry(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/io/InputStream;)V",
            "method_body": "public void addRawArchiveEntry(final ZipArchiveEntry entry, final InputStream rawStream)\nfinal ZipArchiveEntry ae = new ZipArchiveEntry(entry);\nif (hasZip64Extra(ae)) {\nfinal boolean is2PhaseSource = ae.getCrc() != ZipArchiveEntry.CRC_UNKNOWN\nputArchiveEntry(ae, is2PhaseSource);\ncopyFromZipInputStream(rawStream);\ncloseCopiedEntry(is2PhaseSource);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Ljava/nio/ByteBuffer;Lorg/apache/commons/compress/archivers/zip/ZipArchiveOutputStream$EntryMetaData;Z)[B",
            "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze, final ByteBuffer name,\nfinal byte[] extra = ze.getCentralDirectoryExtra();\nString comm = ze.getComment();\nif (comm == null) {\ncomm = \"\";\nfinal ByteBuffer commentB = getEntryEncoding(ze).encode(comm);\nfinal int nameLen = name.limit() - name.position();\nfinal int commentLen = commentB.limit() - commentB.position();\nfinal int len= CFH_FILENAME_OFFSET + nameLen + extra.length + commentLen;\nfinal byte[] buf = new byte[len];\nSystem.arraycopy(CFH_SIG,  0, buf, CFH_SIG_OFFSET, WORD);\nputShort((ze.getPlatform() << 8) | (!hasUsedZip64 ? DATA_DESCRIPTOR_MIN_VERSION : ZIP64_MIN_VERSION),\nfinal int zipMethod = ze.getMethod();\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nputShort(versionNeededToExtract(zipMethod, needsZip64Extra, entryMetaData.usesDataDescriptor),\ngetGeneralPurposeBits(!encodable && fallbackToUTF8, entryMetaData.usesDataDescriptor).encode(buf, CFH_GPB_OFFSET);\nputShort(zipMethod, buf, CFH_METHOD_OFFSET);\nZipUtil.toDosTime(calendarInstance, ze.getTime(), buf, CFH_TIME_OFFSET);\nputLong(ze.getCrc(), buf, CFH_CRC_OFFSET);\nif (ze.getCompressedSize() >= ZIP64_MAGIC\nputLong(ze.getCompressedSize(), buf, CFH_COMPRESSED_SIZE_OFFSET);\nputLong(ze.getSize(), buf, CFH_ORIGINAL_SIZE_OFFSET);\nputShort(nameLen, buf, CFH_FILENAME_LENGTH_OFFSET);\nputShort(extra.length, buf, CFH_EXTRA_LENGTH_OFFSET);\nputShort(commentLen, buf, CFH_COMMENT_LENGTH_OFFSET);\nSystem.arraycopy(ZERO, 0, buf, CFH_DISK_NUMBER_OFFSET, SHORT);\nputShort(ze.getInternalAttributes(), buf, CFH_INTERNAL_ATTRIBUTES_OFFSET);\nputLong(ze.getExternalAttributes(), buf, CFH_EXTERNAL_ATTRIBUTES_OFFSET);\nif (entryMetaData.offset >= ZIP64_MAGIC || zip64Mode == Zip64Mode.Always) {\nputLong(Math.min(entryMetaData.offset, ZIP64_MAGIC), buf, CFH_LFH_OFFSET);\nSystem.arraycopy(name.array(), name.arrayOffset(), buf, CFH_FILENAME_OFFSET, nameLen);\nfinal int extraStart = CFH_FILENAME_OFFSET + nameLen;\nSystem.arraycopy(extra, 0, buf, extraStart, extra.length);\nfinal int commentStart = extraStart + extra.length;\nSystem.arraycopy(commentB.array(), commentB.arrayOffset(), buf, commentStart, commentLen);\nreturn buf;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/nio/channels/SeekableByteChannel;Ljava/lang/String;Ljava/lang/String;ZZ)V",
            "method_body": "private static final int HASH_SIZE = 509;\nprivate final List<ZipArchiveEntry> entries =\nprivate final Map<String, LinkedList<ZipArchiveEntry>> nameMap =\nprivate volatile boolean closed = true;\nprivate final byte[] dwordBuf = new byte[DWORD];\nprivate final byte[] wordBuf = new byte[WORD];\nprivate final byte[] cfhBuf = new byte[CFH_LEN];\nprivate final byte[] shortBuf = new byte[SHORT];\nprivate final ByteBuffer dwordBbuf = ByteBuffer.wrap(dwordBuf);\nprivate final ByteBuffer wordBbuf = ByteBuffer.wrap(wordBuf);\nprivate final ByteBuffer cfhBbuf = ByteBuffer.wrap(cfhBuf);\nthis(f, ZipEncodingHelper.UTF8);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:toDosTime(Ljava/util/Calendar;J[BI)V",
            "method_body": "static void toDosTime(final Calendar c, final long t, final byte[] buf, final int offset) {\nc.setTimeInMillis(t);\nfinal int year = c.get(Calendar.YEAR);\nif (year < 1980) {\nfinal int month = c.get(Calendar.MONTH) + 1;\nfinal long value =  ((year - 1980) << 25)\nZipLong.putLong(value, buf, offset);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeDataDescriptor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "protected void writeDataDescriptor(final ZipArchiveEntry ze) throws IOException {\nif (ze.getMethod() != DEFLATED || channel != null) {\nwriteCounted(DD_SIG);\nwriteCounted(ZipLong.getBytes(ze.getCrc()));\nif (!hasZip64Extra(ze)) {\nwriteCounted(ZipLong.getBytes(ze.getCompressedSize()));\nwriteCounted(ZipLong.getBytes(ze.getSize()));\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([B)J",
            "method_body": "public static long getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedInputStream(final long start, final long remaining) {\nthis.end = start+remaining;\nif (this.end < start) {\nloc = start;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:reset()V",
            "method_body": "void reset() {\ncrc.reset();\ndef.reset();\nsourcePayloadLength = 0;\nwrittenToOutputStreamForLastEntry = 0;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$CurrentEntry:<init>(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "private final ZipArchiveEntry entry;\nprivate long localDataStart = 0;\nprivate long dataStart = 0;\nprivate long bytesRead = 0;\nprivate boolean causedUseOfZip64 = false;\n* #closeArchiveEntry closeArchiveEntry} will write an empty",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:write([BIII)J",
            "method_body": "long write(final byte[] b, final int offset, final int length, final int method) throws IOException {\nfinal long current = writtenToOutputStreamForLastEntry;\ncrc.update(b, offset, length);\nif (method == ZipEntry.DEFLATED) {\nwriteDeflated(b, offset, length);\nsourcePayloadLength += length;\nreturn writtenToOutputStreamForLastEntry - current;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflate()V",
            "method_body": "void deflate() throws IOException {\nfinal int len = def.deflate(outputBuffer, 0, outputBuffer.length);\nif (len > 0) {\nwriteCounted(outputBuffer, 0, len);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile$BoundedFileChannelInputStream:<init>(Lorg/apache/commons/compress/archivers/zip/ZipFile;JJ)V",
            "method_body": "BoundedFileChannelInputStream(final long start, final long remaining) {\nsuper(start, remaining);\narchive = (FileChannel)ZipFile.this.archive;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:flushDeflater()V",
            "method_body": "void flushDeflater() throws IOException {\ndef.finish();\nwhile (!def.finished()) {\ndeflate();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif (finished) {\nif (entry != null) {\ncdOffset = streamCompressor.getTotalBytesWritten();\nwriteCentralDirectoryInChunks();\ncdLength = streamCompressor.getTotalBytesWritten() - cdOffset;\nwriteZip64CentralDirectory();\nwriteCentralDirectoryEnd();\nmetaData.clear();\nentries.clear();\nstreamCompressor.close();\nfinished = true;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:close()V",
            "method_body": "public void close() throws IOException {\nclosed = true;\narchive.close();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/nio/channels/SeekableByteChannel;)V",
            "method_body": "private ZipEncoding zipEncoding =\nprivate boolean useUTF8Flag = true;\nprivate boolean fallbackToUTF8 = false;\nprivate UnicodeExtraFieldPolicy createUnicodeExtraFields = UnicodeExtraFieldPolicy.NEVER;\nprivate boolean hasUsedZip64 = false;\nprivate Zip64Mode zip64Mode = Zip64Mode.AsNeeded;\nprivate final byte[] copyBuffer = new byte[32768];\nprivate final Calendar calendarInstance = Calendar.getInstance();\npublic ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeArchiveEntry()V",
            "method_body": "public void closeArchiveEntry() throws IOException {\npreClose();\nflushDeflater();\nfinal long bytesWritten = streamCompressor.getTotalBytesWritten() - entry.dataStart;\nfinal long realCrc = streamCompressor.getCrc32();\nentry.bytesRead = streamCompressor.getBytesRead();\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nfinal boolean actuallyNeedsZip64 = handleSizesAndCrc(bytesWritten, realCrc, effectiveMode);\ncloseEntry(actuallyNeedsZip64, false);\nstreamCompressor.reset();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;Z)V",
            "method_body": "private void putArchiveEntry(final ArchiveEntry archiveEntry, final boolean phased) throws IOException {\nif (finished) {\nif (entry != null) {\nentry = new CurrentEntry((ZipArchiveEntry) archiveEntry);\nentries.add(entry.entry);\nsetDefaults(entry.entry);\nfinal Zip64Mode effectiveMode = getEffectiveZip64Mode(entry.entry);\nvalidateSizeInformation(effectiveMode);\nif (shouldAddZip64Extra(entry.entry, effectiveMode)) {\nif (entry.entry.getMethod() == DEFLATED && hasCompressionLevelChanged) {\nwriteLocalFileHeader((ZipArchiveEntry) archiveEntry, phased);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(final byte[] data, final boolean local,\nfinal List<ZipExtraField> v = new ArrayList<>();\nint start = 0;\nwhile (start <= data.length - WORD) {\nfinal ZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:deflateUntilInputIsNeeded()V",
            "method_body": "private void deflateUntilInputIsNeeded() throws IOException {\nwhile (!def.needsInput()) {\ndeflate();\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeCentralDirectoryData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeCentralDirectoryData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeDeflated([BII)V",
            "method_body": "private void writeDeflated(final byte[] b, final int offset, final int length)\nif (length > 0 && !def.finished()) {\nif (length <= DEFLATER_BLOCK_SIZE) {\ndef.setInput(b, offset, length);\ndeflateUntilInputIsNeeded();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAllExtraFieldsNoCopy()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "private ZipExtraField[] getAllExtraFieldsNoCopy() {\nif (extraFields == null) {\nreturn getUnparseableOnly();\nreturn unparseableExtra != null ? getMergedFields() : extraFields;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public ZipArchiveOutputStream(final OutputStream out) {\nthis.out = out;\nthis.channel = null;\ndef = new Deflater(level, true);\nstreamCompressor = StreamCompressor.create(out, def);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryEnd()V",
            "method_body": "protected void writeCentralDirectoryEnd() throws IOException {\nwriteCounted(EOCD_SIG);\nwriteCounted(ZERO);\nwriteCounted(ZERO);\nfinal int numberOfEntries = entries.size();\nif (numberOfEntries > ZIP64_MAGIC_SHORT\nif (cdOffset > ZIP64_MAGIC && zip64Mode == Zip64Mode.Never) {\nfinal byte[] num = ZipShort.getBytes(Math.min(numberOfEntries,\nwriteCounted(num);\nwriteCounted(num);\nwriteCounted(ZipLong.getBytes(Math.min(cdLength, ZIP64_MAGIC)));\nwriteCounted(ZipLong.getBytes(Math.min(cdOffset, ZIP64_MAGIC)));\nfinal ByteBuffer data = this.zipEncoding.encode(comment);\nfinal int dataLen = data.limit() - data.position();\nwriteCounted(ZipShort.getBytes(dataLen));\nstreamCompressor.writeCounted(data.array(), data.arrayOffset(), dataLen);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes(I)[B",
            "method_body": "public static byte[] getBytes(final int value) {\nfinal byte[] result = new byte[2];\nputShort(value, result, 0);\nreturn result;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
            "method_body": "private void mergeExtraFields(final ZipExtraField[] f, final boolean local)\nif (extraFields == null) {\nsetExtraFields(f);\nfor (final ZipExtraField element : f) {\nsetExtra();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
            "method_body": "public void setExtra(final byte[] extra) throws RuntimeException {\nfinal ZipExtraField[] local =\nmergeExtraFields(local, true);\n}\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:getEntry(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
            "method_body": "public ZipArchiveEntry getEntry(final String name) {\nfinal LinkedList<ZipArchiveEntry> entriesOfThatName = nameMap.get(name);\nreturn entriesOfThatName != null ? entriesOfThatName.getFirst() : null;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(final ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\nfinal int regularExtraFieldCount =\nint sum = WORD * regularExtraFieldCount;\nfor (final ZipExtraField element : data) {\nfinal byte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nif (lastIsUnparseableHolder) {\nreturn result;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
            "method_body": "public void setExtraFields(final ZipExtraField[] fields) {\nfinal List<ZipExtraField> newFields = new ArrayList<>();\nfor (final ZipExtraField field : fields) {\nextraFields = newFields.toArray(new ZipExtraField[newFields.size()]);\nsetExtra();\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
            "method_body": "public static final int UFT8_NAMES_FLAG = 1 << 11;\nprivate boolean languageEncodingFlag = false;\nprivate boolean dataDescriptorFlag = false;\nprivate boolean encryptionFlag = false;\nprivate boolean strongEncryptionFlag = false;\npublic GeneralPurposeBit() {\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getUnparseableOnly()[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "private ZipExtraField[] getUnparseableOnly() {\nreturn unparseableExtra == null ? noExtraFields : new ZipExtraField[] { unparseableExtra };\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getGeneralPurposeBits(ZZ)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
            "method_body": "private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\nfinal GeneralPurposeBit b = new GeneralPurposeBit();\nb.useUTF8ForNames(useUTF8Flag || utfFallback);\nif (usesDataDescriptor) {\nb.useDataDescriptor(true);\nreturn b;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleSizesAndCrc(JJLorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
            "method_body": "private boolean handleSizesAndCrc(final long bytesWritten, final long crc,\nif (entry.entry.getMethod() == DEFLATED) {\nentry.entry.setSize(entry.bytesRead);\nentry.entry.setCompressedSize(bytesWritten);\nentry.entry.setCrc(crc);\nreturn checkIfNeedsZip64(effectiveMode);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:setDefaults(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "private void setDefaults(final ZipArchiveEntry entry) {\nif (entry.getMethod() == -1) { // not specified\nentry.setMethod(method);\nif (entry.getTime() == -1) { // not specified\nentry.setTime(System.currentTimeMillis());\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(final long size) {\nif (size < 0) {\nthis.size = size;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:close()V",
            "method_body": "public void close() throws IOException {\ndef.end();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEffectiveZip64Mode(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/Zip64Mode;",
            "method_body": "private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\nif (zip64Mode != Zip64Mode.AsNeeded\nreturn zip64Mode;\nreturn Zip64Mode.Never;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
            "method_body": "public void setMethod(final int method) {\nif (method < 0) {\nthis.method = method;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:createCentralFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)[B",
            "method_body": "private byte[] createCentralFileHeader(final ZipArchiveEntry ze) throws IOException {\nfinal EntryMetaData entryMetaData = metaData.get(ze);\nfinal boolean needsZip64Extra = hasZip64Extra(ze)\nif (needsZip64Extra && zip64Mode == Zip64Mode.Never) {\nhandleZip64Extra(ze, entryMetaData.offset, needsZip64Extra);\nreturn createCentralFileHeader(ze, getName(ze), entryMetaData, needsZip64Extra);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "static void checkRequestedFeatures(final ZipArchiveEntry ze)\nif (!supportsEncryptionOf(ze)) {\nif (!supportsMethodOf(ze)) {\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
            "method_body": "public ZipArchiveEntry(final String name) {\nsuper(name);\nsetName(name);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:closeEntry(ZZ)V",
            "method_body": "private void closeEntry(final boolean actuallyNeedsZip64, final boolean phased) throws IOException {\nif (!phased && channel != null) {\nif (!phased) {\nwriteDataDescriptor(entry.entry);\nentry = null;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([BII)V",
            "method_body": "public void writeCounted(final byte[] data, final int offset, final int length) throws IOException {\nwriteOut(data, offset, length);\nwrittenToOutputStreamForLastEntry += length;\ntotalWrittenToOutputStream += length;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:encode([BI)V",
            "method_body": "public void encode(final byte[] buf, final int offset) {\nZipShort.putShort((dataDescriptorFlag ? DATA_DESCRIPTOR_FLAG : 0)\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:preClose()V",
            "method_body": "private void preClose() throws IOException {\nif (finished) {\nif (entry == null) {\nif (!entry.hasWritten) {\nwrite(EMPTY, 0, 0);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:versionNeededToExtract(IZZ)I",
            "method_body": "private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\nif (zip64) {\nif (usedDataDescriptor) {\nreturn DATA_DESCRIPTOR_MIN_VERSION;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
            "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;)V",
            "method_body": "public ZipFile(final File f) throws IOException {\nthis(f, ZipEncodingHelper.UTF8);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;)V",
            "method_body": "public ZipFile(final File f, final String encoding) throws IOException {\nthis(f, encoding, true);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeLocalFileHeader(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Z)V",
            "method_body": "private void writeLocalFileHeader(final ZipArchiveEntry ze, final boolean phased) throws IOException {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nfinal ByteBuffer name = getName(ze);\nif (createUnicodeExtraFields != UnicodeExtraFieldPolicy.NEVER) {\nfinal long localHeaderStart = streamCompressor.getTotalBytesWritten();\nfinal byte[] localHeader = createLocalFileHeader(ze, name, encodable, phased, localHeaderStart);\nmetaData.put(ze, new EntryMetaData(localHeaderStart, usesDataDescriptor(ze.getMethod())));\nentry.localDataStart = localHeaderStart + LFH_CRC_OFFSET; // At crc offset\nwriteCounted(localHeader);\nentry.dataStart = streamCompressor.getTotalBytesWritten();\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:destroy()V",
            "method_body": "void destroy() throws IOException {\nif (channel != null) {\nif (out != null) {\nout.close();\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(Ljava/math/BigInteger;)V",
            "method_body": "public ZipEightByteInteger(final BigInteger value) {\nthis.value = value;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:close()V",
            "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\ndestroy();\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:createBoundedInputStream(JJ)Lorg/apache/commons/compress/archivers/zip/ZipFile$BoundedInputStream;",
            "method_body": "private BoundedInputStream createBoundedInputStream(long start, long remaining) {\nreturn archive instanceof FileChannel ?\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:putShort(I[BI)V",
            "method_body": "public static void putShort(final int value, final byte[] buf, final int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 2);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEightByteInteger:<init>(J)V",
            "method_body": "public ZipEightByteInteger(final long value) {\nthis(BigInteger.valueOf(value));\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
            "method_body": "static final byte[] LFH_SIG = ZipLong.LFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] DD_SIG = ZipLong.DD_SIG.getBytes(); //NOSONAR\nstatic final byte[] CFH_SIG = ZipLong.CFH_SIG.getBytes(); //NOSONAR\nstatic final byte[] EOCD_SIG = ZipLong.getBytes(0X06054B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_SIG = ZipLong.getBytes(0X06064B50L); //NOSONAR\nstatic final byte[] ZIP64_EOCD_LOC_SIG = ZipLong.getBytes(0X07064B50L); //NOSONAR\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream$EntryMetaData:<init>(JZ)V",
            "method_body": "private EntryMetaData(long offset, boolean usesDataDescriptor) {\nthis.offset = offset;\nthis.usesDataDescriptor = usesDataDescriptor;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
            "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getAllExtraFieldsNoCopy()));\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ByteUtils:fromLittleEndian([BII)J",
            "method_body": "public static long fromLittleEndian(byte[] bytes, final int off, final int length) {\ncheckReadLength(length);\nlong l = 0;\nfor (int i = 0; i < length; i++) {\nl |= (bytes[off + i] & 0xffl) << (8 * i);\nreturn l;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipFile:<init>(Ljava/io/File;Ljava/lang/String;Z)V",
            "method_body": "public ZipFile(final File f, final String encoding, final boolean useUnicodeExtraFields)\nthis(Files.newByteChannel(f.toPath(), EnumSet.of(StandardOpenOption.READ)),\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
            "method_body": "public void useUTF8ForNames(final boolean b) {\nlanguageEncodingFlag = b;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:flushDeflater()V",
            "method_body": "private void flushDeflater() throws IOException {\nif (entry.entry.getMethod() == DEFLATED) {\nstreamCompressor.flushDeflater();\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(final long value) {\nfinal byte[] result = new byte[WORD];\nputLong(value, result, 0);\nreturn result;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
            "method_body": "public static long getValue(final byte[] bytes, final int offset) {\nreturn ByteUtils.fromLittleEndian(bytes, offset, 4);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:checkIfNeedsZip64(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
            "method_body": "private boolean checkIfNeedsZip64(final Zip64Mode effectiveMode)\nfinal boolean actuallyNeedsZip64 = isZip64Required(entry.entry, effectiveMode);\nif (actuallyNeedsZip64 && effectiveMode == Zip64Mode.Never) {\nreturn actuallyNeedsZip64;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getInternalAttributes()I",
            "method_body": "public int getInternalAttributes() {\nreturn internalAttributes;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getCentralDirectoryExtra()[B",
            "method_body": "public byte[] getCentralDirectoryExtra() {\nreturn ExtraFieldUtils.mergeCentralDirectoryData(getAllExtraFieldsNoCopy());\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getAlignment()I",
            "method_body": "protected int getAlignment() {\nreturn this.alignment;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField getExtraField(final ZipShort type) {\nif (extraFields != null) {\nfor (final ZipExtraField extraField : extraFields) {\nreturn null;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCentralDirectoryInChunks()V",
            "method_body": "private void writeCentralDirectoryInChunks() throws IOException {\nfinal int NUM_PER_WRITE = 1000;\nfinal ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(70 * NUM_PER_WRITE);\nint count = 0;\nfor (final ZipArchiveEntry ze : entries) {\nbyteArrayOutputStream.write(createCentralFileHeader(ze));\nif (++count > NUM_PER_WRITE){\n}\nwriteCounted(byteArrayOutputStream.toByteArray());\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getBytesRead()J",
            "method_body": "public long getBytesRead() {\nreturn sourcePayloadLength;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getCrc32()J",
            "method_body": "public long getCrc32() {\nreturn crc.getValue();\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ByteUtils:toLittleEndian([BJII)V",
            "method_body": "public static void toLittleEndian(final byte[] b, final long value, final int off, final int length) {\nlong num = value;\nfor (int i = 0; i < length; i++) {\nb[off + i] = (byte) (num & 0xff);\nnum >>= 8;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:getTotalBytesWritten()J",
            "method_body": "public long getTotalBytesWritten() {\nreturn totalWrittenToOutputStream;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(final long value) {\nthis.value = value;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
            "method_body": "public ZipShort (final int value) {\nthis.value = value;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExternalAttributes()J",
            "method_body": "public long getExternalAttributes() {\nreturn externalAttributes;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:validateSizeInformation(Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)V",
            "method_body": "private void validateSizeInformation(final Zip64Mode effectiveMode)\nif (entry.entry.getMethod() == STORED && channel == null) {\nif ((entry.entry.getSize() >= ZIP64_MAGIC\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([B)I",
            "method_body": "public static int getValue(final byte[] bytes) {\nreturn getValue(bytes, 0);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<init>()V",
            "method_body": "public ResourceAlignmentExtraField() {\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ResourceAlignmentExtraField:<init>(IZI)V",
            "method_body": "public static final ZipShort ID = new ZipShort(0xa11e);\nprivate int padding = 0;\npublic ResourceAlignmentExtraField() {\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn size;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getLocalFileDataExtra()[B",
            "method_body": "public byte[] getLocalFileDataExtra() {\nfinal byte[] extra = getExtra();\nreturn extra != null ? extra : EMPTY;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getEntryEncoding(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
            "method_body": "private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\nfinal boolean encodable = zipEncoding.canEncode(ze.getName());\nreturn !encodable && fallbackToUTF8\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:handleZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;JZ)V",
            "method_body": "private void handleZip64Extra(final ZipArchiveEntry ze, final long lfhOffset,\nif (needsZip64Extra) {\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:putLong(J[BI)V",
            "method_body": "public static void putLong(final long value, final byte[] buf, int offset) {\nByteUtils.toLittleEndian(buf, value, offset, 4);\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
            "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nputArchiveEntry(archiveEntry, false);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
            "method_body": "public int getPlatform() {\nreturn platform;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsMethodOf(final ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.StreamCompressor:writeCounted([B)V",
            "method_body": "public void writeCounted(final byte[] data) throws IOException {\nwriteCounted(data, 0, data.length);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsEncryptionOf(final ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
            "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
            "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:write([BII)V",
            "method_body": "public void write(final byte[] b, final int offset, final int length) throws IOException {\nif (entry == null) {\nZipUtil.checkRequestedFeatures(entry.entry);\nfinal long writtenThisTime = streamCompressor.write(b, offset, length, entry.entry.getMethod());\ncount(writtenThisTime);\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
            "method_body": "public static int getValue(final byte[] bytes, final int offset) {\nreturn (int) ByteUtils.fromLittleEndian(bytes, offset, 2);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
            "method_body": "public int getCode() {\nreturn code;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
            "method_body": "public int getMethod() {\nreturn method;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ByteUtils:checkReadLength(I)V",
            "method_body": "private static final void checkReadLength(int length) {\nif (length > 8) {\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeZip64CentralDirectory()V",
            "method_body": "protected void writeZip64CentralDirectory() throws IOException {\nif (zip64Mode == Zip64Mode.Never) {\nif (!hasUsedZip64\nif (!hasUsedZip64) {\nreturn;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isTooLageForZip32(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private boolean isTooLageForZip32(final ZipArchiveEntry zipArchiveEntry){\nreturn zipArchiveEntry.getSize() >= ZIP64_MAGIC || zipArchiveEntry.getCompressedSize() >= ZIP64_MAGIC;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
            "method_body": "public void useDataDescriptor(final boolean b) {\ndataDescriptorFlag = b;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:isZip64Required(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
            "method_body": "private boolean isZip64Required(final ZipArchiveEntry entry1, final Zip64Mode requestedMode) {\nreturn requestedMode == Zip64Mode.Always || isTooLageForZip32(entry1);\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:shouldAddZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;Lorg/apache/commons/compress/archivers/zip/Zip64Mode;)Z",
            "method_body": "private boolean shouldAddZip64Extra(final ZipArchiveEntry entry, final Zip64Mode mode) {\nreturn mode == Zip64Mode.Always\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:hasZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private boolean hasZip64Extra(final ZipArchiveEntry ze) {\nreturn ze.getExtraField(Zip64ExtendedInformationExtraField\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:getName(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Ljava/nio/ByteBuffer;",
            "method_body": "private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\nreturn getEntryEncoding(ze).encode(ze.getName());\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getDataOffset()J",
            "method_body": "public long getDataOffset() {\nreturn dataOffset;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
            "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }",
            "method_id": 119
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:writeCounted([B)V",
            "method_body": "private void writeCounted(final byte[] data) throws IOException {\nstreamCompressor.writeCounted(data);\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:usesDataDescriptor(I)Z",
            "method_body": "private boolean usesDataDescriptor(final int zipMethod) {\nreturn zipMethod == DEFLATED && channel == null;\n}",
            "method_id": 121
        }
    ]
}