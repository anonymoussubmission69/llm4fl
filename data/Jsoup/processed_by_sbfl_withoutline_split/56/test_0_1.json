{
    "bug_id": 56,
    "test_id": 0,
    "test_name": "org.jsoup.nodes.DocumentTypeTest.testRoundTrip",
    "test_body": "@Test public void testRoundTrip() {\nString base = \"<!DOCTYPE html>\";\nassertEquals(\"<!doctype html>\", htmlOutput(base));\nassertEquals(base, xmlOutput(base));\n49: String publicDoc = \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Transitional//EN\\\" \\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\\\">\";\nassertEquals(publicDoc, htmlOutput(publicDoc));\nassertEquals(publicDoc, xmlOutput(publicDoc));\n53: String systemDoc = \"<!DOCTYPE html SYSTEM \\\"exampledtdfile.dtd\\\">\";\nassertEquals(systemDoc, htmlOutput(systemDoc));\nassertEquals(systemDoc, xmlOutput(systemDoc));",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<<!DOCTYPE html [SYSTEM ]\"exampledtdfile.dtd\"...> but was:<<!DOCTYPE html []\"exampledtdfile.dtd\"...>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.jsoup.nodes.DocumentTypeTest.testRoundTrip(DocumentTypeTest.java:54)",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName, ParseSettings settings) {\nValidate.notNull(tagName);\nTag tag = tags.get(tagName);\nif (tag == null) {\ntagName = settings.normalizeTag(tagName);\nValidate.notEmpty(tagName);\ntag = tags.get(tagName);\nif (tag == null) {\ntag = new Tag(tagName);\ntag.isBlock = false;\ntag.canContainBlock = true;\nreturn tag;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isFormListed()Z",
            "method_body": "public boolean isFormListed() {\nreturn formList;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)V",
            "method_body": "private static void register(Tag tag) {\ntags.put(tag.tagName, tag);\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>()V",
            "method_body": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\nprivate Charset charset = Charset.forName(\"UTF-8\");\nprivate boolean prettyPrint = true;\nprivate boolean outline = false;\nprivate int indentAmount = 1;\nprivate Syntax syntax = Syntax.html;\npublic OutputSettings() {}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:syntax()Lorg/jsoup/nodes/Document$OutputSettings$Syntax;",
            "method_body": "public Syntax syntax() {\nreturn syntax;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:syntax(Lorg/jsoup/nodes/Document$OutputSettings$Syntax;)Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings syntax(Syntax syntax) {\nthis.syntax = syntax;\nreturn this;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<init>(Ljava/lang/String;ILjava/lang/String;I)V",
            "method_body": "EscapeMode(String file, int size) {\nload(this, file, size);\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<clinit>()V",
            "method_body": "private static final int empty = -1;\npublic enum EscapeMode {\nxhtml(\"entities-xhtml.properties\", 4),\nbase(\"entities-base.properties\", 106),\nextended(\"entities-full.properties\", 2125);\nEscapeMode(String file, int size) {\nload(this, file, size);\n}\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:<clinit>()V",
            "method_body": "private static final char[] codeDelims = {',', ';'};\nprivate static final char[] codeDelims = {',', ';'};",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:load(Lorg/jsoup/nodes/Entities$EscapeMode;Ljava/lang/String;I)V",
            "method_body": "private static void load(EscapeMode e, String file, int size) {\ne.nameKeys = new String[size];\ne.codeVals = new int[size];\ne.codeKeys = new int[size];\ne.nameVals = new String[size];\nInputStream stream = Entities.class.getResourceAsStream(file);\nif (stream == null)\nint i = 0;\nByteBuffer bytes = DataUtil.readToByteBuffer(stream, 0);\nString contents = Charset.forName(\"ascii\").decode(bytes).toString();\nCharacterReader reader = new CharacterReader(contents);\nwhile (!reader.isEmpty()) {\nfinal String name = reader.consumeTo('=');\nreader.advance();\nfinal int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\nfinal char codeDelim = reader.current();\nreader.advance();\nif (codeDelim == ',') {\ncp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\nreader.advance();\ncp2 = empty;\nfinal int index = Integer.parseInt(reader.consumeTo('\\n'), codepointRadix);\nreader.advance();\ne.nameKeys[i] = name;\ne.codeVals[i] = cp1;\ne.codeKeys[index] = cp1;\ne.nameVals[index] = name;\nif (cp2 != empty) {\nmultipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\ni++;\n}\n}\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:<clinit>()V",
            "method_body": "private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:\\\"|')?([^\\\\s,;\\\"']*)\");\nprivate static final char[] mimeBoundaryChars =\nprivate DataUtil() {}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:readToByteBuffer(Ljava/io/InputStream;I)Ljava/nio/ByteBuffer;",
            "method_body": "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\nValidate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\nfinal boolean capped = maxSize > 0;\nbyte[] buffer = new byte[capped && maxSize < bufferSize ? maxSize : bufferSize];\nByteArrayOutputStream outStream = new ByteArrayOutputStream(capped ? maxSize : bufferSize);\nint remaining = maxSize;\nread = inStream.read(buffer);\nif (read == -1) break;\nif (capped) {\noutStream.write(buffer, 0, read);\nreturn ByteBuffer.wrap(outStream.toByteArray());\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "public CharacterReader(String input) {\nValidate.notNull(input);\nthis.input = input.toCharArray();\nthis.length = this.input.length;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn pos >= length;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "public char current() {\nreturn pos >= length ? EOF : input[pos];\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nchar val = pos >= length ? EOF : input[pos];\npos++;\nreturn val;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "public void advance() {\npos++;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:nextIndexOf(C)I",
            "method_body": "int nextIndexOf(char c) {\nfor (int i = pos; i < length; i++) {\nif (c == input[i])\nreturn i - pos;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTo(C)Ljava/lang/String;",
            "method_body": "public String consumeTo(char c) {\nint offset = nextIndexOf(c);\nif (offset != -1) {\nString consumed = cacheString(pos, offset);\npos += offset;\nreturn consumed;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAny([C)Ljava/lang/String;",
            "method_body": "public String consumeToAny(final char... chars) {\nfinal int start = pos;\nfinal int remaining = length;\nfinal char[] val = input;\nOUTER: while (pos < remaining) {\nfor (char c : chars) {\nif (val[pos] == c)\nbreak OUTER;\npos++;\nreturn pos > start ? cacheString(start, pos-start) : \"\";\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeLetterSequence()Ljava/lang/String;",
            "method_body": "String consumeLetterSequence() {\nint start = pos;\nwhile (pos < length) {\nchar c = input[pos];\nif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\npos++;\n}\nreturn cacheString(start, pos - start);\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matches(C)Z",
            "method_body": "boolean matches(char c) {\nreturn !isEmpty() && input[pos] == c;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matches(Ljava/lang/String;)Z",
            "method_body": "boolean matches(String seq) {\nint scanLength = seq.length();\nif (scanLength > length - pos)\nfor (int offset = 0; offset < scanLength; offset++)\nif (seq.charAt(offset) != input[pos+offset])\nreturn false;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesIgnoreCase(Ljava/lang/String;)Z",
            "method_body": "boolean matchesIgnoreCase(String seq) {\nint scanLength = seq.length();\nif (scanLength > length - pos)\nfor (int offset = 0; offset < scanLength; offset++) {\nchar upScan = Character.toUpperCase(seq.charAt(offset));\nchar upTarget = Character.toUpperCase(input[pos + offset]);\nif (upScan != upTarget)\nreturn false;\nreturn true;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesAny([C)Z",
            "method_body": "boolean matchesAny(char... seq) {\nif (isEmpty())\nchar c = input[pos];\nfor (char seek : seq) {\nif (seek == c)\nreturn false;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nchar c = input[pos];\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchConsume(Ljava/lang/String;)Z",
            "method_body": "boolean matchConsume(String seq) {\nif (matches(seq)) {\nreturn false;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchConsumeIgnoreCase(Ljava/lang/String;)Z",
            "method_body": "boolean matchConsumeIgnoreCase(String seq) {\nif (matchesIgnoreCase(seq)) {\npos += seq.length();\nreturn true;\nreturn false;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:cacheString(II)Ljava/lang/String;",
            "method_body": "private String cacheString(final int start, final int count) {\nfinal char[] val = input;\nfinal String[] cache = stringCache;\nif (count > maxCacheLen)\nreturn new String(val, start, count);\nint hash = 0;\nint offset = start;\nfor (int i = 0; i < count; i++) {\nhash = 31 * hash + val[offset++];\nfinal int index = hash & cache.length - 1;\nString cached = cache[index];\nif (cached == null) { // miss, add\ncached = new String(val, start, count);\ncache[index] = cached;\nif (rangeEquals(start, count, cached)) { // hit\nreturn cached;\ncached = new String(val, start, count);\ncache[index] = cached; // update the cache, as recently used strings are more likely to show up again\nreturn cached;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:rangeEquals(IILjava/lang/String;)Z",
            "method_body": "boolean rangeEquals(final int start, int count, final String cached) {\nif (count == cached.length()) {\nchar one[] = input;\nint i = start;\nint j = 0;\nwhile (count-- != 0) {\nif (one[i++] != cached.charAt(j++))\nreturn false;\nreturn true;\nreturn false;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "private final CharacterReader reader; // html input\nprivate TokeniserState state = TokeniserState.Data; // current tokenisation state\nprivate boolean isEmitPending = false;\nprivate String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\nprivate StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\nStringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\nToken.StartTag startPending = new Token.StartTag();\nToken.EndTag endPending = new Token.EndTag();\nToken.Character charPending = new Token.Character();\nToken.Doctype doctypePending = new Token.Doctype(); // doctype building up\nToken.Comment commentPending = new Token.Comment(); // comment building up\nprivate boolean selfClosingFlagAcknowledged = true;\nTokeniser(CharacterReader reader, ParseErrorList errors) {\nthis.reader = reader;\nthis.errors = errors;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:read()Lorg/jsoup/parser/Token;",
            "method_body": "Token read() {\nif (!selfClosingFlagAcknowledged) {\nwhile (!isEmitPending)\nstate.read(this, reader);\nif (charsBuilder.length() > 0) {\n} else if (charsString != null) {\nisEmitPending = false;\nreturn emitPending;\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\nemitPending = token;\nisEmitPending = true;\nif (token.type == Token.TokenType.StartTag) {\n} else if (token.type == Token.TokenType.EndTag) {\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:transition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void transition(TokeniserState state) {\nthis.state = state;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createDoctypePending()V",
            "method_body": "void createDoctypePending() {\ndoctypePending.reset();\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitDoctypePending()V",
            "method_body": "void emitDoctypePending() {\nemit(doctypePending);\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:error(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void error(TokeniserState state) {\nif (errors.canAddError())\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\nt.advanceTransition(TagOpen);\nbreak;\nt.emit(new Token.EOF());\nbreak;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\nt.advanceTransition(MarkupDeclarationOpen);\nbreak;\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$44:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchConsume(\"--\")) {\n} else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\nt.transition(Doctype);\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$51:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(BeforeDoctypeName);\nbreak;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$52:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nt.createDoctypePending();\nt.transition(DoctypeName);\nreturn;\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$53:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nString name = r.consumeLetterSequence();\nt.doctypePending.name.append(name);\nreturn;\nchar c = r.consume();\nswitch (c) {\nt.emitDoctypePending();\nt.transition(Data);\nbreak;\nt.transition(AfterDoctypeName);\nbreak;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$54:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\nif (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\nelse if (r.matches('>')) {\n} else if (r.matchConsumeIgnoreCase(DocumentType.PUBLIC_KEY)) {\nt.transition(AfterDoctypePublicKeyword);\n} else if (r.matchConsumeIgnoreCase(DocumentType.SYSTEM_KEY)) {\nt.transition(AfterDoctypeSystemKeyword);\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$55:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(BeforeDoctypePublicIdentifier);\nbreak;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$56:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(DoctypePublicIdentifier_doubleQuoted);\nbreak;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$57:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(AfterDoctypePublicIdentifier);\nbreak;\nt.doctypePending.publicIdentifier.append(c);\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$59:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(BetweenDoctypePublicAndSystemIdentifiers);\nbreak;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$60:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.error(this);\nt.transition(DoctypeSystemIdentifier_doubleQuoted);\nbreak;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$61:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(BeforeDoctypeSystemIdentifier);\nbreak;\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$62:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(DoctypeSystemIdentifier_doubleQuoted);\nbreak;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$63:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.transition(AfterDoctypeSystemIdentifier);\nbreak;\nt.doctypePending.systemIdentifier.append(c);\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$65:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\nt.emitDoctypePending();\nt.transition(Data);\nbreak;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>()V",
            "method_body": "Character() {\nsuper();\ntype = TokenType.Character;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:<init>()V",
            "method_body": "final StringBuilder name = new StringBuilder();\nfinal StringBuilder publicIdentifier = new StringBuilder();\nfinal StringBuilder systemIdentifier = new StringBuilder();\nboolean forceQuirks = false;\nDoctype() {\ntype = TokenType.Doctype;\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreset(name);\nreset(publicIdentifier);\nreset(systemIdentifier);\nforceQuirks = false;\nreturn this;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:getName()Ljava/lang/String;",
            "method_body": "String getName() {\nreturn name.toString();\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:getPublicIdentifier()Ljava/lang/String;",
            "method_body": "String getPublicIdentifier() {\nreturn publicIdentifier.toString();\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:getSystemIdentifier()Ljava/lang/String;",
            "method_body": "public String getSystemIdentifier() {\nreturn systemIdentifier.toString();\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:isForceQuirks()Z",
            "method_body": "public boolean isForceQuirks() {\nreturn forceQuirks;\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:<init>()V",
            "method_body": "final StringBuilder data = new StringBuilder();\nboolean bogus = false;\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public Attribute(String key, String value) {\nValidate.notEmpty(key);\nValidate.notNull(value);\nthis.key = key.trim();\nthis.value = value;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:<clinit>()V",
            "method_body": "private static final String[] booleanAttributes = {\n};",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getKey()Ljava/lang/String;",
            "method_body": "public String getKey() {\nreturn key;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getValue()Ljava/lang/String;",
            "method_body": "public String getValue() {\nreturn value;\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$24:<clinit>()V",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nswitch (t.type) {\nToken.EndTag end = t.asEndTag();\nname = end.normalName();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\nreturn anythingElse(t, tb);\nreturn true;\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:<clinit>()V",
            "method_body": "private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\nprivate static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};",
            "method_id": 167
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isBlank(Ljava/lang/String;)Z",
            "method_body": "public static boolean isBlank(String string) {\nif (string == null || string.length() == 0)\nreturn true;\nint l = string.length();\nfor (int i = 0; i < l; i++) {\nif (!StringUtil.isWhitespace(string.codePointAt(i)))\nreturn false;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isWhitespace(I)Z",
            "method_body": "public static boolean isWhitespace(int c){\nreturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreturn this;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:<init>(Lorg/jsoup/select/NodeVisitor;)V",
            "method_body": "public NodeTraversor(NodeVisitor visitor) {\nthis.visitor = visitor;\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:traverse(Lorg/jsoup/nodes/Node;)V",
            "method_body": "public void traverse(Node root) {\nNode node = root;\nint depth = 0;\nwhile (node != null) {\nvisitor.head(node, depth);\nif (node.childNodeSize() > 0) {\nwhile (node.nextSibling() == null && depth > 0) {\nvisitor.tail(node, depth);\nif (node == root)\nbreak;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:<init>(Ljava/lang/Appendable;Lorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\nthis.accum = accum;\nthis.out = out;\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:head(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void head(Node node, int depth) {\nnode.outerHtmlHead(accum, depth, out);\n}\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:tail(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void tail(Node node, int depth) {\nif (!node.nodeName().equals(\"#text\")) { // saves a void hit.\nnode.outerHtmlTail(accum, depth, out);\n}\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.jsoup.nodes.DocumentType:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\nsuper(baseUri);\nattr(NAME, name);\nattr(PUBLIC_ID, publicId);\nattr(SYSTEM_ID, systemId);\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.jsoup.nodes.DocumentType:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#doctype\";\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.jsoup.nodes.DocumentType:outerHtmlHead(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\nif (out.syntax() == Syntax.html && !has(PUBLIC_ID) && !has(SYSTEM_ID)) {\naccum.append(\"<!doctype\");\naccum.append(\"<!DOCTYPE\");\nif (has(NAME))\naccum.append(\" \").append(attr(NAME));\nif (has(PUBLIC_ID))\naccum.append(\" PUBLIC \\\"\").append(attr(PUBLIC_ID)).append('\"');\nif (has(SYSTEM_ID))\naccum.append(\" \\\"\").append(attr(SYSTEM_ID)).append('\"');\naccum.append('>');\n}",
            "method_id": 179
        },
        {
            "method_signature": "org.jsoup.nodes.DocumentType:outerHtmlTail(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) {\n}",
            "method_id": 180
        },
        {
            "method_signature": "org.jsoup.nodes.DocumentType:has(Ljava/lang/String;)Z",
            "method_body": "private boolean has(final String attribute) {\nreturn !StringUtil.isBlank(attr(attribute));\n}",
            "method_id": 181
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:process(Lorg/jsoup/parser/Token;)Z",
            "method_body": "protected boolean process(Token token) {\nswitch (token.type) {\ninsert(token.asDoctype());\nbreak;\nbreak;\nValidate.fail(\"Unexpected token type: \" + token.type);\nreturn true;\n}",
            "method_id": 182
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:defaultSettings()Lorg/jsoup/parser/ParseSettings;",
            "method_body": "ParseSettings defaultSettings() {\nreturn ParseSettings.preserveCase;\n}",
            "method_id": 183
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:initialiseParse(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)V",
            "method_body": "protected void initialiseParse(String input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nsuper.initialiseParse(input, baseUri, errors, settings);\nstack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\ndoc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n}",
            "method_id": 184
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:insertNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void insertNode(Node node) {\ncurrentElement().appendChild(node);\n}",
            "method_id": 185
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Doctype;)V",
            "method_body": "void insert(Token.Doctype d) {\nDocumentType doctypeNode = new DocumentType(settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier(), baseUri);\ninsertNode(doctypeNode);\n}",
            "method_id": 186
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder$1:<clinit>()V",
            "method_body": "protected boolean process(Token token) {\nswitch (token.type) {\ninsert(token.asDoctype());\nbreak;\nbreak;\nValidate.fail(\"Unexpected token type: \" + token.type);\nreturn true;\n}",
            "method_id": 187
        }
    ]
}