{
    "bug_id": 6,
    "test_id": 0,
    "test_name": "org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord",
    "test_body": "public void testToMapWithShortRecord() throws Exception {\nfinal CSVParser parser =  CSVParser.parse(\"a,b\", CSVFormat.DEFAULT.withHeader(\"A\", \"B\", \"C\"));\nfinal CSVRecord shortRec = parser.iterator().next();\nshortRec.toMap();\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 2\nat org.apache.commons.csv.CSVRecord.putIn(CSVRecord.java:182)\nat org.apache.commons.csv.CSVRecord.toMap(CSVRecord.java:212)\nat org.apache.commons.csv.CSVRecordTest.testToMapWithShortRecord(CSVRecordTest.java:167)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:putIn(Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "<M extends Map<String, String>> M putIn(final M map) {\nfor (final Entry<String, Integer> entry : mapping.entrySet()) {\nfinal int col = entry.getValue().intValue();\nmap.put(entry.getKey(), values[col]);\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:toMap()Ljava/util/Map;",
            "method_body": "public Map<String, String> toMap() {\nreturn putIn(new HashMap<String, String>(values.length));\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:<init>(Ljava/io/Reader;Lorg/apache/commons/csv/CSVFormat;)V",
            "method_body": "public CSVParser(final Reader reader, final CSVFormat format) throws IOException {\nAssertions.notNull(reader, \"reader\");\nAssertions.notNull(format, \"format\");\nformat.validate();\nthis.format = format;\nthis.lexer = new Lexer(format, new ExtendedBufferedReader(reader));\nthis.headerMap = this.initializeHeader();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:<init>(CLjava/lang/Character;Lorg/apache/commons/csv/Quote;Ljava/lang/Character;Ljava/lang/Character;ZZLjava/lang/String;Ljava/lang/String;[Ljava/lang/String;Z)V",
            "method_body": "CSVFormat(final char delimiter, final Character quoteChar,\nfinal String nullString, final String[] header, final boolean skipHeaderRecord) {\nif (isLineBreak(delimiter)) {\nthis.delimiter = delimiter;\nthis.quoteChar = quoteChar;\nthis.quotePolicy = quotePolicy;\nthis.commentStart = commentStart;\nthis.escape = escape;\nthis.ignoreSurroundingSpaces = ignoreSurroundingSpaces;\nthis.ignoreEmptyLines = ignoreEmptyLines;\nthis.recordSeparator = recordSeparator;\nthis.nullString = nullString;\nthis.header = header == null ? null : header.clone();\nthis.skipHeaderRecord = skipHeaderRecord;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:parse(Ljava/lang/String;Lorg/apache/commons/csv/CSVFormat;)Lorg/apache/commons/csv/CSVParser;",
            "method_body": "public static CSVParser parse(final String string, final CSVFormat format) throws IOException {\nAssertions.notNull(string, \"string\");\nAssertions.notNull(format, \"format\");\nreturn new CSVParser(new StringReader(string), format);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:<init>([Ljava/lang/String;Ljava/util/Map;Ljava/lang/String;J)V",
            "method_body": "CSVRecord(final String[] values, final Map<String, Integer> mapping,\nfinal String comment, final long recordNumber) {\nthis.recordNumber = recordNumber;\nthis.values = values != null ? values : EMPTY_STRING_ARRAY;\nthis.mapping = mapping;\nthis.comment = comment;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.csv.CSVParser:iterator()Ljava/util/Iterator;",
            "method_body": "public Iterator<CSVRecord> iterator() {\nreturn new Iterator<CSVRecord>() {\nreturn CSVParser.this.nextRecord();\nif (CSVParser.this.isClosed()) {\nCSVRecord next = this.current;\nthis.current = null;\nif (next == null) {\nnext = this.getNextRecord();\nif (next == null) {\nreturn next;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.csv.Assertions:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(final Object parameter, final String parameterName) {\nif (parameter == null) {\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.csv.CSVFormat:withHeader([Ljava/lang/String;)Lorg/apache/commons/csv/CSVFormat;",
            "method_body": "public CSVFormat withHeader(final String... header) {\nreturn new CSVFormat(delimiter, quoteChar, quotePolicy, commentStart, escape,\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.csv.CSVRecord:<clinit>()V",
            "method_body": "private static final String[] EMPTY_STRING_ARRAY = new String[0];\nfinal String comment, final long recordNumber) {\nthis.recordNumber = recordNumber;\nthis.values = values != null ? values : EMPTY_STRING_ARRAY;\nthis.mapping = mapping;\nthis.comment = comment;\n}",
            "method_id": 9
        }
    ]
}