{
    "projects": [
        {
            "name": "Time",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestPartial_Constructors.testConstructorEx7_TypeArray_intArray",
                            "test_body": "260: public void testConstructorEx7_TypeArray_intArray() throws Throwable {\n261: int[] values = new int[] {1, 1, 1};\n262: DateTimeFieldType[] types = new DateTimeFieldType[] {\n263: DateTimeFieldType.dayOfMonth(), DateTimeFieldType.year(), DateTimeFieldType.monthOfYear() };\n264: try {\n265: new Partial(types, values);\n266: fail();\n267: } catch (IllegalArgumentException ex) {\n268: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n269: }\n270: 271: types = new DateTimeFieldType[] {\n272: DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.monthOfYear() };\n273: try {\n274: new Partial(types, values);\n275: fail();\n276: } catch (IllegalArgumentException ex) {\n277: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n278: }\n279: 280: types = new DateTimeFieldType[] {\n281: DateTimeFieldType.year(), DateTimeFieldType.era(), DateTimeFieldType.monthOfYear() };\n282: try {\n283: new Partial(types, values);\n284: fail();\n285: } catch (IllegalArgumentException ex) {\n286: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n287: }\n288: 289: types = new DateTimeFieldType[] {\n290: DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.era() };\n291: try {\n292: new Partial(types, values);\n293: fail();\n294: } catch (IllegalArgumentException ex) {\n295: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n296: }\n297: 298: types = new DateTimeFieldType[] {\n299: DateTimeFieldType.year(), DateTimeFieldType.dayOfMonth(), DateTimeFieldType.dayOfYear() };\n300: try {\n301: new Partial(types, values);\n302: fail();\n303: } catch (IllegalArgumentException ex) {\n304: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n305: }\n306: 307: types = new DateTimeFieldType[] {\n308: DateTimeFieldType.yearOfEra(), DateTimeFieldType.year(), DateTimeFieldType.dayOfYear() };\n309: try {\n310: new Partial(types, values);\n311: fail();\n312: } catch (IllegalArgumentException ex) {\n313: assertMessageContains(ex, \"must be in order\", \"largest-smallest\");\n314: }\n315: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>([Lorg/joda/time/DateTimeFieldType;[I)V",
                                    "method_body": "public Partial(DateTimeFieldType[] types, int[] values) {\nthis(types, values, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>([Lorg/joda/time/DateTimeFieldType;[ILorg/joda/time/Chronology;)V",
                                    "method_body": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\niChronology = chronology;\nif (types == null) {\nif (values == null) {\nif (values.length != types.length) {\nif (types.length == 0) {\nfor (int i = 0; i < types.length; i++) {\nif (types[i] == null) {\nDurationField lastUnitField = null;\nfor (int i = 0; i < types.length; i++) {\nDateTimeFieldType loopType = types[i];\nDurationField loopUnitField = loopType.getDurationType().getField(iChronology);\nif (i > 0) {\nint compare = lastUnitField.compareTo(loopUnitField);\nif (compare < 0) {\nthrow new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n} else if (compare == 0) {\nlastUnitField = loopUnitField;\niTypes = (DateTimeFieldType[]) types.clone();\nchronology.validate(this, values);\niValues = (int[]) values.clone();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:size()I",
                                    "method_body": "public int size() {\nreturn iTypes.length;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nreturn iTypes[index].getField(chrono);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestPartial_Basics.testWith_baseAndArgHaveNoRange",
                            "test_body": "467: public void testWith_baseAndArgHaveNoRange() {\n468: Partial test = new Partial(DateTimeFieldType.year(), 1);\n469: Partial result = test.with(DateTimeFieldType.era(), 1);\n470: assertEquals(2, result.size());\n471: assertEquals(0, result.indexOf(DateTimeFieldType.era()));\n472: assertEquals(1, result.indexOf(DateTimeFieldType.year()));\n473: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.UnsupportedDurationField:<init>(Lorg/joda/time/DurationFieldType;)V",
                                    "method_body": "private UnsupportedDurationField(DurationFieldType type) {\niType = type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.UnsupportedDurationField:getInstance(Lorg/joda/time/DurationFieldType;)Lorg/joda/time/field/UnsupportedDurationField;",
                                    "method_body": "public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\nif (cCache == null) {\ncCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\nfield = null;\nfield = cCache.get(type);\nif (field == null) {\nfield = new UnsupportedDurationField(type);\ncCache.put(type, field);\nreturn field;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.UnsupportedDurationField:isSupported()Z",
                                    "method_body": "public boolean isSupported() {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.UnsupportedDurationField:getUnitMillis()J",
                                    "method_body": "public long getUnitMillis() {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.UnsupportedDurationField:compareTo(Lorg/joda/time/DurationField;)I",
                                    "method_body": "public int compareTo(DurationField durationField) {\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public Partial(DateTimeFieldType type, int value) {\nthis(type, value, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>(Lorg/joda/time/DateTimeFieldType;ILorg/joda/time/Chronology;)V",
                                    "method_body": "public Partial(DateTimeFieldType type, int value, Chronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\niChronology = chronology;\nif (type == null) {\niTypes = new DateTimeFieldType[] {type};\niValues = new int[] {value};\nchronology.validate(this, iValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>([Lorg/joda/time/DateTimeFieldType;[ILorg/joda/time/Chronology;)V",
                                    "method_body": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\niChronology = chronology;\nif (types == null) {\nif (values == null) {\nif (values.length != types.length) {\nif (types.length == 0) {\nfor (int i = 0; i < types.length; i++) {\nif (types[i] == null) {\nDurationField lastUnitField = null;\nfor (int i = 0; i < types.length; i++) {\nDateTimeFieldType loopType = types[i];\nDurationField loopUnitField = loopType.getDurationType().getField(iChronology);\nif (i > 0) {\nint compare = lastUnitField.compareTo(loopUnitField);\nif (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n} else if (compare == 0) {\nif (types[i - 1].getRangeDurationType() == null) {\nif (loopType.getRangeDurationType() == null) {\nthrow new IllegalArgumentException(\"Types array must not contain duplicate: \" +\nlastUnitField = loopUnitField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:size()I",
                                    "method_body": "public int size() {\nreturn iTypes.length;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nreturn iTypes[index].getField(chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:with(Lorg/joda/time/DateTimeFieldType;I)Lorg/joda/time/Partial;",
                                    "method_body": "public Partial with(DateTimeFieldType fieldType, int value) {\nif (fieldType == null) {\nint index = indexOf(fieldType);\nif (index == -1) {\nDateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\nint[] newValues = new int[newTypes.length];\nint i = 0;\nDurationField unitField = fieldType.getDurationType().getField(iChronology);\nif (unitField.isSupported()) {\nSystem.arraycopy(iTypes, 0, newTypes, 0, i);\nSystem.arraycopy(iValues, 0, newValues, 0, i);\nnewTypes[i] = fieldType;\nnewValues[i] = value;\nSystem.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\nSystem.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\nPartial newPartial = new Partial(newTypes, newValues, iChronology);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddYears_int_dstOverlapWinter_addZero",
                            "test_body": "222: public void testAddYears_int_dstOverlapWinter_addZero() {\n223: MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n224: test.addHours(1);\n225: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n226: test.addYears(0);\n227: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n228: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
                                    "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
                                    "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
                                    "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
                                    "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addYears(I)V",
                                    "method_body": "public void addYears(final int years) {\nsetMillis(getChronology().years().add(getMillis(), years));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddWeeks_int_dstOverlapWinter_addZero",
                            "test_body": "295: public void testAddWeeks_int_dstOverlapWinter_addZero() {\n296: MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n297: test.addHours(1);\n298: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n299: test.addWeeks(0);\n300: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n301: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
                                    "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
                                    "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
                                    "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
                                    "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addWeeks(I)V",
                                    "method_body": "public void addWeeks(final int weeks) {\nsetMillis(getChronology().weeks().add(getMillis(), weeks));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddDays_int_dstOverlapWinter_addZero",
                            "test_body": "266: public void testAddDays_int_dstOverlapWinter_addZero() {\n267: MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n268: test.addHours(1);\n269: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n270: test.addDays(0);\n271: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n272: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
                                    "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
                                    "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
                                    "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
                                    "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addDays(I)V",
                                    "method_body": "public void addDays(final int days) {\nsetMillis(getChronology().days().add(getMillis(), days));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddMonths_int_dstOverlapWinter_addZero",
                            "test_body": "244: public void testAddMonths_int_dstOverlapWinter_addZero() {\n245: MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n246: test.addHours(1);\n247: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n248: test.addMonths(0);\n249: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n250: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
                                    "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
                                    "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
                                    "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
                                    "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addMonths(I)V",
                                    "method_body": "public void addMonths(final int months) {\nsetMillis(getChronology().months().add(getMillis(), months));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMutableDateTime_Adds.testAdd_DurationFieldType_int_dstOverlapWinter_addZero",
                            "test_body": "182: public void testAdd_DurationFieldType_int_dstOverlapWinter_addZero() {\n183: MutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\n184: test.addHours(1);\n185: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n186: test.add(DurationFieldType.years(), 0);\n187: assertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n188: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
                                    "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
                                    "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
                                    "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
                                    "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\nbreak;\nsuper.setMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:add(Lorg/joda/time/DurationFieldType;I)V",
                                    "method_body": "public void add(DurationFieldType type, int amount) {\nif (type == null) {\nsetMillis(type.getField(getChronology()).add(getMillis(), amount));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
                                    "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestPartial_Basics.testWith3",
                            "test_body": "360: public void testWith3() {\n361: Partial test = createHourMinPartial();\n362: try {\n363: test.with(DateTimeFieldType.clockhourOfDay(), 6);\n364: fail();\n365: } catch (IllegalArgumentException ex) {}\n366: check(test, 10, 20);\n367: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:millisOfSecond()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType millisOfSecond() {\nreturn MILLIS_OF_SECOND_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>([Lorg/joda/time/DateTimeFieldType;[ILorg/joda/time/Chronology;)V",
                                    "method_body": "public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\niChronology = chronology;\nif (types == null) {\nif (values == null) {\nif (values.length != types.length) {\nif (types.length == 0) {\nfor (int i = 0; i < types.length; i++) {\nif (types[i] == null) {\nDurationField lastUnitField = null;\nfor (int i = 0; i < types.length; i++) {\nDateTimeFieldType loopType = types[i];\nDurationField loopUnitField = loopType.getDurationType().getField(iChronology);\nif (i > 0) {\nint compare = lastUnitField.compareTo(loopUnitField);\nif (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n} else if (compare == 0) {\nlastUnitField = loopUnitField;\niTypes = (DateTimeFieldType[]) types.clone();\nchronology.validate(this, values);\niValues = (int[]) values.clone();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:<init>(Lorg/joda/time/Chronology;[Lorg/joda/time/DateTimeFieldType;[I)V",
                                    "method_body": "Partial(Chronology chronology, DateTimeFieldType[] types, int[] values) {\nsuper();\niChronology = chronology;\niTypes = types;\niValues = values;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:size()I",
                                    "method_body": "public int size() {\nreturn iTypes.length;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nreturn iTypes[index].getField(chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:getFieldType(I)Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public DateTimeFieldType getFieldType(int index) {\nreturn iTypes[index];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Partial:with(Lorg/joda/time/DateTimeFieldType;I)Lorg/joda/time/Partial;",
                                    "method_body": "public Partial with(DateTimeFieldType fieldType, int value) {\nif (fieldType == null) {\nint index = indexOf(fieldType);\nif (index == -1) {\nDateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\nint[] newValues = new int[newTypes.length];\nint i = 0;\nDurationField unitField = fieldType.getDurationType().getField(iChronology);\nif (unitField.isSupported()) {\nfor (; i < iTypes.length; i++) {\nDateTimeFieldType loopType = iTypes[i];\nDurationField loopUnitField = loopType.getDurationType().getField(iChronology);\nif (loopUnitField.isSupported()) {\nint compare = unitField.compareTo(loopUnitField);\nif (compare > 0) {\nbreak;\n} else if (compare == 0) {\nDurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\nDurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\nif (rangeField.compareTo(loopRangeField) > 0) {\nSystem.arraycopy(iTypes, 0, newTypes, 0, i);\nSystem.arraycopy(iValues, 0, newValues, 0, i);\nnewTypes[i] = fieldType;\nnewValues[i] = value;\nSystem.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\nSystem.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\nPartial newPartial = new Partial(iChronology, newTypes, newValues);\niChronology.validate(newPartial, newValues);\nreturn newPartial;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months1",
                            "test_body": "1520: public void testNormalizedStandard_periodType_months1() {\n1521: Period test = new Period(1, 15, 0, 0, 0, 0, 0, 0);\n1522: Period result = test.normalizedStandard(PeriodType.months());\n1523: assertEquals(new Period(1, 15, 0, 0, 0, 0, 0, 0), test);\n1524: assertEquals(new Period(0, 27, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n1525: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
                                    "method_body": "public static final PeriodType getPeriodType(PeriodType type) {\nif (type == null) {\nreturn PeriodType.standard();\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:minutes()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType minutes() {\nreturn MINUTES_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:hours()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType hours() {\nreturn HOURS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:weeks()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType weeks() {\nreturn WEEKS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
                                    "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\ncStandard = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:months()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType months() {\nPeriodType type = cMonths;\nif (type == null) {\ntype = new PeriodType(\ncMonths = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
                                    "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:setIndexedField(Lorg/joda/time/ReadablePeriod;I[II)Z",
                                    "method_body": "boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\nint realIndex = iIndices[index];\nif (realIndex == -1) {\nthrow new UnsupportedOperationException(\"Field is not supported\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(IIIIIIII)V",
                                    "method_body": "public Period(int years, int months, int weeks, int days,\nsuper(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
                                    "method_body": "public Period(long duration, PeriodType type, Chronology chronology) {\nsuper(duration, type, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<clinit>()V",
                                    "method_body": "public static final Period ZERO = new Period();\n* Parses a {@code Period} from the specified string."
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getYears()I",
                                    "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getWeeks()I",
                                    "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getDays()I",
                                    "method_body": "public int getDays() {\nreturn getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getHours()I",
                                    "method_body": "public int getHours() {\nreturn getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMinutes()I",
                                    "method_body": "public int getMinutes() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getSeconds()I",
                                    "method_body": "public int getSeconds() {\nreturn getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMillis()I",
                                    "method_body": "public int getMillis() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:withYears(I)Lorg/joda/time/Period;",
                                    "method_body": "public Period withYears(int years) {\nint[] values = getValues();  // cloned\ngetPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:normalizedStandard(Lorg/joda/time/PeriodType;)Lorg/joda/time/Period;",
                                    "method_body": "public Period normalizedStandard(PeriodType type) {\ntype = DateTimeUtils.getPeriodType(type);\nlong millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\nmillis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\nmillis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\nmillis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\nmillis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\nmillis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\nPeriod result = new Period(millis, type, ISOChronology.getInstanceUTC());\nint years = getYears();\nint months = getMonths();\nif (years != 0 || months != 0) {\nyears = FieldUtils.safeAdd(years, months / 12);\nmonths = months % 12;\nif (years != 0) {\nresult = result.withYears(years);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_monthsWeeks",
                            "test_body": "1551: public void testNormalizedStandard_periodType_monthsWeeks() {\n1552: PeriodType type = PeriodType.forFields(new DurationFieldType[]{\n1553: DurationFieldType.months(),\n1554: DurationFieldType.weeks(),\n1555: DurationFieldType.days()});\n1556: Period test = new Period(2, 4, 6, 0, 0, 0, 0, 0);\n1557: Period result = test.normalizedStandard(type);\n1558: assertEquals(new Period(2, 4, 6, 0, 0, 0, 0, 0), test);\n1559: assertEquals(new Period(0, 28, 6, 0, 0, 0, 0, 0, type), result);\n1560: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
                                    "method_body": "public static final PeriodType getPeriodType(PeriodType type) {\nif (type == null) {\nreturn PeriodType.standard();\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:minutes()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType minutes() {\nreturn MINUTES_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:hours()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType hours() {\nreturn HOURS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:weeks()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType weeks() {\nreturn WEEKS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
                                    "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\ncStandard = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:months()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType months() {\nPeriodType type = cMonths;\nif (type == null) {\ntype = new PeriodType(\ncMonths = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
                                    "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:setIndexedField(Lorg/joda/time/ReadablePeriod;I[II)Z",
                                    "method_body": "boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\nint realIndex = iIndices[index];\nif (realIndex == -1) {\nthrow new UnsupportedOperationException(\"Field is not supported\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(IIIIIIII)V",
                                    "method_body": "public Period(int years, int months, int weeks, int days,\nsuper(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
                                    "method_body": "public Period(long duration, PeriodType type, Chronology chronology) {\nsuper(duration, type, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<clinit>()V",
                                    "method_body": "public static final Period ZERO = new Period();\n* Parses a {@code Period} from the specified string."
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getYears()I",
                                    "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getWeeks()I",
                                    "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getDays()I",
                                    "method_body": "public int getDays() {\nreturn getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getHours()I",
                                    "method_body": "public int getHours() {\nreturn getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMinutes()I",
                                    "method_body": "public int getMinutes() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getSeconds()I",
                                    "method_body": "public int getSeconds() {\nreturn getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMillis()I",
                                    "method_body": "public int getMillis() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:withYears(I)Lorg/joda/time/Period;",
                                    "method_body": "public Period withYears(int years) {\nint[] values = getValues();  // cloned\ngetPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:normalizedStandard(Lorg/joda/time/PeriodType;)Lorg/joda/time/Period;",
                                    "method_body": "public Period normalizedStandard(PeriodType type) {\ntype = DateTimeUtils.getPeriodType(type);\nlong millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\nmillis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\nmillis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\nmillis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\nmillis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\nmillis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\nPeriod result = new Period(millis, type, ISOChronology.getInstanceUTC());\nint years = getYears();\nint months = getMonths();\nif (years != 0 || months != 0) {\nyears = FieldUtils.safeAdd(years, months / 12);\nmonths = months % 12;\nif (years != 0) {\nresult = result.withYears(years);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
                                    "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearMonthDayTime()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearMonthDayTime() {\nPeriodType type = cYMDTime;\nif (type == null) {\ntype = new PeriodType(\ncYMDTime = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearMonthDay()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearMonthDay() {\nPeriodType type = cYMD;\nif (type == null) {\ntype = new PeriodType(\ncYMD = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearWeekDayTime()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearWeekDayTime() {\nPeriodType type = cYWDTime;\nif (type == null) {\ntype = new PeriodType(\ncYWDTime = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearWeekDay()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearWeekDay() {\nPeriodType type = cYWD;\nif (type == null) {\ntype = new PeriodType(\ncYWD = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearDayTime()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearDayTime() {\nPeriodType type = cYDTime;\nif (type == null) {\ntype = new PeriodType(\ncYDTime = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:yearDay()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType yearDay() {\nPeriodType type = cYD;\nif (type == null) {\ntype = new PeriodType(\ncYD = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:dayTime()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType dayTime() {\nPeriodType type = cDTime;\nif (type == null) {\ntype = new PeriodType(\ncDTime = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:time()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType time() {\nPeriodType type = cTime;\nif (type == null) {\ntype = new PeriodType(\ncTime = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:years()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType years() {\nPeriodType type = cYears;\nif (type == null) {\ntype = new PeriodType(\ncYears = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:weeks()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType weeks() {\nPeriodType type = cWeeks;\nif (type == null) {\ntype = new PeriodType(\ncWeeks = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:days()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType days() {\nPeriodType type = cDays;\nif (type == null) {\ntype = new PeriodType(\ncDays = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:hours()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType hours() {\nPeriodType type = cHours;\nif (type == null) {\ntype = new PeriodType(\ncHours = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:minutes()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType minutes() {\nPeriodType type = cMinutes;\nif (type == null) {\ntype = new PeriodType(\ncMinutes = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:seconds()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType seconds() {\nPeriodType type = cSeconds;\nif (type == null) {\ntype = new PeriodType(\ncSeconds = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:millis()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType millis() {\nPeriodType type = cMillis;\nif (type == null) {\ntype = new PeriodType(\ncMillis = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:forFields([Lorg/joda/time/DurationFieldType;)Lorg/joda/time/PeriodType;",
                                    "method_body": "public static synchronized PeriodType forFields(DurationFieldType[] types) {\nif (types == null || types.length == 0) {\nfor (int i = 0; i < types.length; i++) {\nif (types[i] == null) {\nMap<PeriodType, Object> cache = cTypes;\nif (cache.isEmpty()) {\ncache.put(standard(), standard());\ncache.put(yearMonthDayTime(), yearMonthDayTime());\ncache.put(yearMonthDay(), yearMonthDay());\ncache.put(yearWeekDayTime(), yearWeekDayTime());\ncache.put(yearWeekDay(), yearWeekDay());\ncache.put(yearDayTime(), yearDayTime());\ncache.put(yearDay(), yearDay());\ncache.put(dayTime(), dayTime());\ncache.put(time(), time());\ncache.put(years(), years());\ncache.put(months(), months());\ncache.put(weeks(), weeks());\ncache.put(days(), days());\ncache.put(hours(), hours());\ncache.put(minutes(), minutes());\ncache.put(seconds(), seconds());\ncache.put(millis(), millis());\nPeriodType inPartType = new PeriodType(null, types, null);\nObject cached = cache.get(inPartType);\nif (cached instanceof PeriodType) {\nif (cached != null) {\nPeriodType type = standard();\nList<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\nif (list.remove(DurationFieldType.years()) == false) {\ntype = type.withYearsRemoved();\nif (list.remove(DurationFieldType.months()) == false) {\nif (list.remove(DurationFieldType.weeks()) == false) {\nif (list.remove(DurationFieldType.days()) == false) {\nif (list.remove(DurationFieldType.hours()) == false) {\ntype = type.withHoursRemoved();\nif (list.remove(DurationFieldType.minutes()) == false) {\ntype = type.withMinutesRemoved();\nif (list.remove(DurationFieldType.seconds()) == false) {\ntype = type.withSecondsRemoved();\nif (list.remove(DurationFieldType.millis()) == false) {\ntype = type.withMillisRemoved();\nif (list.size() > 0) {\nPeriodType checkPartType = new PeriodType(null, type.iTypes, null);\nPeriodType checkedType = (PeriodType) cache.get(checkPartType);\nif (checkedType != null) {\ncache.put(checkPartType, type);\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getName()Ljava/lang/String;",
                                    "method_body": "public String getName() {\nreturn iName;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:size()I",
                                    "method_body": "public int size() {\nreturn iTypes.length;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withYearsRemoved()Lorg/joda/time/PeriodType;",
                                    "method_body": "public PeriodType withYearsRemoved() {\nreturn withFieldRemoved(0, \"NoYears\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withHoursRemoved()Lorg/joda/time/PeriodType;",
                                    "method_body": "public PeriodType withHoursRemoved() {\nreturn withFieldRemoved(4, \"NoHours\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withMinutesRemoved()Lorg/joda/time/PeriodType;",
                                    "method_body": "public PeriodType withMinutesRemoved() {\nreturn withFieldRemoved(5, \"NoMinutes\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withSecondsRemoved()Lorg/joda/time/PeriodType;",
                                    "method_body": "public PeriodType withSecondsRemoved() {\nreturn withFieldRemoved(6, \"NoSeconds\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withMillisRemoved()Lorg/joda/time/PeriodType;",
                                    "method_body": "public PeriodType withMillisRemoved() {\nreturn withFieldRemoved(7, \"NoMillis\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:withFieldRemoved(ILjava/lang/String;)Lorg/joda/time/PeriodType;",
                                    "method_body": "private PeriodType withFieldRemoved(int indicesIndex, String name) {\nint fieldIndex = iIndices[indicesIndex];\nif (fieldIndex == -1) {\nDurationFieldType[] types = new DurationFieldType[size() - 1];\nfor (int i = 0; i < iTypes.length; i++) {\nif (i < fieldIndex) {\ntypes[i] = iTypes[i];\n} else if (i > fieldIndex) {\ntypes[i - 1] = iTypes[i];\nint[] indices = new int[8];\nfor (int i = 0; i < indices.length; i++) {\nif (i < indicesIndex) {\nindices[i] = iIndices[i];\n} else if (i > indicesIndex) {\nindices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\nindices[i] = -1;\nreturn new PeriodType(getName() + name, types, indices);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestPeriod_Basics.testNormalizedStandard_periodType_months2",
                            "test_body": "1527: public void testNormalizedStandard_periodType_months2() {\n1528: Period test = new Period(-2, 15, 0, 0, 0, 0, 0, 0);\n1529: Period result = test.normalizedStandard(PeriodType.months());\n1530: assertEquals(new Period(-2, 15, 0, 0, 0, 0, 0, 0), test);\n1531: assertEquals(new Period(0, -9, 0, 0, 0, 0, 0, 0, PeriodType.months()), result);\n1532: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
                                    "method_body": "public static final PeriodType getPeriodType(PeriodType type) {\nif (type == null) {\nreturn PeriodType.standard();\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:minutes()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType minutes() {\nreturn MINUTES_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:hours()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType hours() {\nreturn HOURS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:weeks()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType weeks() {\nreturn WEEKS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
                                    "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\ncStandard = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:months()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType months() {\nPeriodType type = cMonths;\nif (type == null) {\ntype = new PeriodType(\ncMonths = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
                                    "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:setIndexedField(Lorg/joda/time/ReadablePeriod;I[II)Z",
                                    "method_body": "boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\nint realIndex = iIndices[index];\nif (realIndex == -1) {\nthrow new UnsupportedOperationException(\"Field is not supported\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(IIIIIIII)V",
                                    "method_body": "public Period(int years, int months, int weeks, int days,\nsuper(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
                                    "method_body": "public Period(long duration, PeriodType type, Chronology chronology) {\nsuper(duration, type, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<clinit>()V",
                                    "method_body": "public static final Period ZERO = new Period();\n* Parses a {@code Period} from the specified string."
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getYears()I",
                                    "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getWeeks()I",
                                    "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getDays()I",
                                    "method_body": "public int getDays() {\nreturn getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getHours()I",
                                    "method_body": "public int getHours() {\nreturn getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMinutes()I",
                                    "method_body": "public int getMinutes() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getSeconds()I",
                                    "method_body": "public int getSeconds() {\nreturn getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMillis()I",
                                    "method_body": "public int getMillis() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:withYears(I)Lorg/joda/time/Period;",
                                    "method_body": "public Period withYears(int years) {\nint[] values = getValues();  // cloned\ngetPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:normalizedStandard(Lorg/joda/time/PeriodType;)Lorg/joda/time/Period;",
                                    "method_body": "public Period normalizedStandard(PeriodType type) {\ntype = DateTimeUtils.getPeriodType(type);\nlong millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\nmillis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\nmillis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\nmillis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\nmillis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\nmillis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\nPeriod result = new Period(millis, type, ISOChronology.getInstanceUTC());\nint years = getYears();\nint months = getMonths();\nif (years != 0 || months != 0) {\nyears = FieldUtils.safeAdd(years, months / 12);\nmonths = months % 12;\nif (years != 0) {\nresult = result.withYears(years);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 6,
                    "tests": [
                        {
                            "test_name": "org.joda.time.chrono.TestGJDate.test_cutoverPreZero",
                            "test_body": "128: public void test_cutoverPreZero() {\n129: DateTime cutover = new LocalDate(-2, 6, 30, ISOChronology.getInstanceUTC()).toDateTimeAtStartOfDay(DateTimeZone.UTC);\n130: try {\n131: GJChronology.getInstance(DateTimeZone.UTC, cutover);\n132: fail();\n133: } catch (IllegalArgumentException ex) {\n134: // expected\n135: }\n136: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n(from.year().get(instant),\nfrom.monthOfYear().get(instant),\nfrom.dayOfMonth().get(instant),\nfrom.millisOfDay().get(instant));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nsynchronized (cCache) {\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i = chronos.size(); --i >= 0;) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\nchronos.add(chrono);\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\njulian.dayOfYear(), fields.dayOfYear, cutover);\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\njulian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\nfields.year = new ImpreciseCutoverField(\njulian.year(), fields.year, iCutoverMillis);\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\njulian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\nfields.yearOfCentury = new ImpreciseCutoverField(\njulian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\nfields.centuryOfEra = new ImpreciseCutoverField(\njulian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\njulian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\njulian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\nfields.weekyearOfCentury = new ImpreciseCutoverField(\njulian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\n(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\nthis(julianField, gregorianField, null, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\nthis(julianField, gregorianField, durationField, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;JZ)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n{\nsuper(julianField, gregorianField, cutoverMillis, convertByWeekyear);\nif (durationField == null) {\ndurationField = new LinkedDurationField(iDurationField, this);\niDurationField = durationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:convertLocalToUTC(JZ)J",
                                    "method_body": "public long convertLocalToUTC(long instantLocal, boolean strict) {\nint offsetLocal = getOffset(instantLocal);\nint offset = getOffset(instantLocal - offsetLocal);\nif (offsetLocal != offset) {\nlong instantUTC = instantLocal - offset;\nif ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\nreturn instantUTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:toDateTimeAtStartOfDay(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime toDateTimeAtStartOfDay(DateTimeZone zone) {\nzone = DateTimeUtils.getZone(zone);\nChronology chrono = getChronology().withZone(zone);\nlong localMillis = getLocalMillis() + 6L * DateTimeConstants.MILLIS_PER_HOUR;\nlong instant = zone.convertLocalToUTC(localMillis, false);\ninstant = chrono.dayOfMonth().roundFloor(instant);\nreturn new DateTime(instant, chrono);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.chrono.TestGJDate.test_plusWeekyears_positiveToZero_crossCutover",
                            "test_body": "115: public void test_plusWeekyears_positiveToZero_crossCutover() {\n116: LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n117: LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n118: assertEquals(expected, date.weekyear().addToCopy(-2003));\n119: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n(from.year().get(instant),\nfrom.monthOfYear().get(instant),\nfrom.dayOfMonth().get(instant),\nfrom.millisOfDay().get(instant));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nsynchronized (cCache) {\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i = chronos.size(); --i >= 0;) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\nchronos.add(chrono);\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nif ((base = getBase()) != null) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withUTC()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withUTC() {\nreturn withZone(DateTimeZone.UTC);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withZone(DateTimeZone zone) {\nif (zone == null) {\nif (zone == getZone()) {\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIII)J",
                                    "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = getBase()) != null) {\nlong instant = iGregorianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant < iCutoverMillis) {\ninstant = iJulianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant >= iCutoverMillis) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\njulian.dayOfYear(), fields.dayOfYear, cutover);\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\njulian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\nfields.year = new ImpreciseCutoverField(\njulian.year(), fields.year, iCutoverMillis);\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\njulian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\nfields.yearOfCentury = new ImpreciseCutoverField(\njulian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\nfields.centuryOfEra = new ImpreciseCutoverField(\njulian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\njulian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\njulian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\nfields.weekyearOfCentury = new ImpreciseCutoverField(\njulian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\n(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\nthis(julianField, gregorianField, null, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\nthis(julianField, gregorianField, durationField, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;JZ)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n{\nsuper(julianField, gregorianField, cutoverMillis, convertByWeekyear);\nif (durationField == null) {\ndurationField = new LinkedDurationField(iDurationField, this);\niDurationField = durationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:add(JI)J",
                                    "method_body": "public long add(long instant, int value) {\nif (instant >= iCutover) {\ninstant = iGregorianField.add(instant, value);\nif (instant < iCutover) {\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withLocalMillis(J)Lorg/joda/time/LocalDate;",
                                    "method_body": "LocalDate withLocalMillis(long newMillis) {\nnewMillis = iChronology.dayOfMonth().roundFloor(newMillis);\nreturn (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:gregorianToJulianByWeekyear(J)J",
                                    "method_body": "long gregorianToJulianByWeekyear(long instant) {\nreturn convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getWeekOfWeekyear()I",
                                    "method_body": "public int getWeekOfWeekyear() {\nreturn getChronology().weekOfWeekyear().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getDayOfWeek()I",
                                    "method_body": "public int getDayOfWeek() {\nreturn getChronology().dayOfWeek().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withWeekOfWeekyear(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\nreturn withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withDayOfWeek(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate withDayOfWeek(int dayOfWeek) {\nreturn withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:weekyear()Lorg/joda/time/LocalDate$Property;",
                                    "method_body": "public Property weekyear() {\nreturn new Property(this, getChronology().weekyear());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate$Property:<init>(Lorg/joda/time/LocalDate;Lorg/joda/time/DateTimeField;)V",
                                    "method_body": "Property(LocalDate instant, DateTimeField field) {\nsuper();\niInstant = instant;\niField = field;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate$Property:addToCopy(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate addToCopy(int value) {\nreturn iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.chrono.TestGJDate.test_plusYears_positiveToNegative_crossCutover",
                            "test_body": "102: public void test_plusYears_positiveToNegative_crossCutover() {\n103: LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n104: LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY);\n105: assertEquals(expected, date.plusYears(-2004));\n106: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n(from.year().get(instant),\nfrom.monthOfYear().get(instant),\nfrom.dayOfMonth().get(instant),\nfrom.millisOfDay().get(instant));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nsynchronized (cCache) {\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i = chronos.size(); --i >= 0;) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\nchronos.add(chrono);\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nif ((base = getBase()) != null) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withUTC()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withUTC() {\nreturn withZone(DateTimeZone.UTC);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withZone(DateTimeZone zone) {\nif (zone == null) {\nif (zone == getZone()) {\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIII)J",
                                    "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = getBase()) != null) {\nlong instant = iGregorianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant < iCutoverMillis) {\ninstant = iJulianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant >= iCutoverMillis) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\njulian.dayOfYear(), fields.dayOfYear, cutover);\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\njulian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\nfields.year = new ImpreciseCutoverField(\njulian.year(), fields.year, iCutoverMillis);\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\njulian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\nfields.yearOfCentury = new ImpreciseCutoverField(\njulian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\nfields.centuryOfEra = new ImpreciseCutoverField(\njulian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\njulian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\njulian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\nfields.weekyearOfCentury = new ImpreciseCutoverField(\njulian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\n(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:gregorianToJulianByYear(J)J",
                                    "method_body": "long gregorianToJulianByYear(long instant) {\nreturn convertByYear(instant, iGregorianChronology, iJulianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\nthis(julianField, gregorianField, null, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\nthis(julianField, gregorianField, durationField, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;JZ)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n{\nsuper(julianField, gregorianField, cutoverMillis, convertByWeekyear);\nif (durationField == null) {\ndurationField = new LinkedDurationField(iDurationField, this);\niDurationField = durationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:add(JI)J",
                                    "method_body": "public long add(long instant, int value) {\nif (instant >= iCutover) {\ninstant = iGregorianField.add(instant, value);\nif (instant < iCutover) {\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:plusYears(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate plusYears(int years) {\nif (years == 0) {\nlong instant = getChronology().years().add(getLocalMillis(), years);\nreturn withLocalMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withLocalMillis(J)Lorg/joda/time/LocalDate;",
                                    "method_body": "LocalDate withLocalMillis(long newMillis) {\nnewMillis = iChronology.dayOfMonth().roundFloor(newMillis);\nreturn (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.chrono.TestGJDate.test_plusYears_positiveToZero_crossCutover",
                            "test_body": "96: public void test_plusYears_positiveToZero_crossCutover() {\n97: LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n98: LocalDate expected = new LocalDate(-1, 6, 30, GJ_CHRONOLOGY);\n99: assertEquals(expected, date.plusYears(-2003));\n100: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n(from.year().get(instant),\nfrom.monthOfYear().get(instant),\nfrom.dayOfMonth().get(instant),\nfrom.millisOfDay().get(instant));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nsynchronized (cCache) {\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i = chronos.size(); --i >= 0;) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\nchronos.add(chrono);\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nif ((base = getBase()) != null) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withUTC()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withUTC() {\nreturn withZone(DateTimeZone.UTC);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withZone(DateTimeZone zone) {\nif (zone == null) {\nif (zone == getZone()) {\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIII)J",
                                    "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = getBase()) != null) {\nlong instant = iGregorianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant < iCutoverMillis) {\ninstant = iJulianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant >= iCutoverMillis) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\njulian.dayOfYear(), fields.dayOfYear, cutover);\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\njulian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\nfields.year = new ImpreciseCutoverField(\njulian.year(), fields.year, iCutoverMillis);\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\njulian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\nfields.yearOfCentury = new ImpreciseCutoverField(\njulian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\nfields.centuryOfEra = new ImpreciseCutoverField(\njulian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\njulian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\njulian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\nfields.weekyearOfCentury = new ImpreciseCutoverField(\njulian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\n(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:gregorianToJulianByYear(J)J",
                                    "method_body": "long gregorianToJulianByYear(long instant) {\nreturn convertByYear(instant, iGregorianChronology, iJulianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\nthis(julianField, gregorianField, null, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\nthis(julianField, gregorianField, durationField, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;JZ)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n{\nsuper(julianField, gregorianField, cutoverMillis, convertByWeekyear);\nif (durationField == null) {\ndurationField = new LinkedDurationField(iDurationField, this);\niDurationField = durationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:add(JI)J",
                                    "method_body": "public long add(long instant, int value) {\nif (instant >= iCutover) {\ninstant = iGregorianField.add(instant, value);\nif (instant < iCutover) {\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:plusYears(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate plusYears(int years) {\nif (years == 0) {\nlong instant = getChronology().years().add(getLocalMillis(), years);\nreturn withLocalMillis(instant);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.chrono.TestGJDate.test_plusWeekyears_positiveToNegative_crossCutover",
                            "test_body": "121: public void test_plusWeekyears_positiveToNegative_crossCutover() {\n122: LocalDate date = new LocalDate(2003, 6, 30, GJ_CHRONOLOGY);\n123: LocalDate expected = new LocalDate(-2, 6, 30, GJ_CHRONOLOGY).withWeekOfWeekyear(date.getWeekOfWeekyear()).withDayOfWeek(date.getDayOfWeek());\n124: assertEquals(expected, date.weekyear().addToCopy(-2004));\n125: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n(from.year().get(instant),\nfrom.monthOfYear().get(instant),\nfrom.dayOfMonth().get(instant),\nfrom.millisOfDay().get(instant));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nsynchronized (cCache) {\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i = chronos.size(); --i >= 0;) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\nchronos.add(chrono);\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nif ((base = getBase()) != null) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withUTC()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withUTC() {\nreturn withZone(DateTimeZone.UTC);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology withZone(DateTimeZone zone) {\nif (zone == null) {\nif (zone == getZone()) {\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIII)J",
                                    "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = getBase()) != null) {\nlong instant = iGregorianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant < iCutoverMillis) {\ninstant = iJulianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant >= iCutoverMillis) {\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\njulian.dayOfYear(), fields.dayOfYear, cutover);\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\njulian.weekOfWeekyear(), fields.weekOfWeekyear, cutover, true);\nfields.year = new ImpreciseCutoverField(\njulian.year(), fields.year, iCutoverMillis);\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\njulian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\nfields.yearOfCentury = new ImpreciseCutoverField(\njulian.yearOfCentury(), fields.yearOfCentury, fields.years, iCutoverMillis);\nfields.centuryOfEra = new ImpreciseCutoverField(\njulian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\njulian.monthOfYear(), fields.monthOfYear, iCutoverMillis);\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\njulian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\nfields.weekyearOfCentury = new ImpreciseCutoverField(\njulian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, iCutoverMillis);\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\n(julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField, long cutoverMillis) {\nthis(julianField, gregorianField, null, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;J)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\nthis(julianField, gregorianField, durationField, cutoverMillis, false);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:<init>(Lorg/joda/time/chrono/GJChronology;Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeField;Lorg/joda/time/DurationField;JZ)V",
                                    "method_body": "ImpreciseCutoverField(DateTimeField julianField, DateTimeField gregorianField,\n{\nsuper(julianField, gregorianField, cutoverMillis, convertByWeekyear);\nif (durationField == null) {\ndurationField = new LinkedDurationField(iDurationField, this);\niDurationField = durationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology$ImpreciseCutoverField:add(JI)J",
                                    "method_body": "public long add(long instant, int value) {\nif (instant >= iCutover) {\ninstant = iGregorianField.add(instant, value);\nif (instant < iCutover) {\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\nreturn instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withLocalMillis(J)Lorg/joda/time/LocalDate;",
                                    "method_body": "LocalDate withLocalMillis(long newMillis) {\nnewMillis = iChronology.dayOfMonth().roundFloor(newMillis);\nreturn (newMillis == getLocalMillis() ? this : new LocalDate(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByWeekyear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByWeekyear(final long instant, Chronology from, Chronology to) {\nnewInstant = to.weekyear().set(0, from.weekyear().get(instant));\nnewInstant = to.weekOfWeekyear().set(newInstant, from.weekOfWeekyear().get(instant));\nnewInstant = to.dayOfWeek().set(newInstant, from.dayOfWeek().get(instant));\nnewInstant = to.millisOfDay().set(newInstant, from.millisOfDay().get(instant));\nreturn newInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:gregorianToJulianByWeekyear(J)J",
                                    "method_body": "long gregorianToJulianByWeekyear(long instant) {\nreturn convertByWeekyear(instant, iGregorianChronology, iJulianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getWeekOfWeekyear()I",
                                    "method_body": "public int getWeekOfWeekyear() {\nreturn getChronology().weekOfWeekyear().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getDayOfWeek()I",
                                    "method_body": "public int getDayOfWeek() {\nreturn getChronology().dayOfWeek().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withWeekOfWeekyear(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate withWeekOfWeekyear(int weekOfWeekyear) {\nreturn withLocalMillis(getChronology().weekOfWeekyear().set(getLocalMillis(), weekOfWeekyear));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:withDayOfWeek(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate withDayOfWeek(int dayOfWeek) {\nreturn withLocalMillis(getChronology().dayOfWeek().set(getLocalMillis(), dayOfWeek));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:weekyear()Lorg/joda/time/LocalDate$Property;",
                                    "method_body": "public Property weekyear() {\nreturn new Property(this, getChronology().weekyear());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate$Property:<init>(Lorg/joda/time/LocalDate;Lorg/joda/time/DateTimeField;)V",
                                    "method_body": "Property(LocalDate instant, DateTimeField field) {\nsuper();\niInstant = instant;\niField = field;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate$Property:addToCopy(I)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate addToCopy(int value) {\nreturn iInstant.withLocalMillis(iField.add(iInstant.getLocalMillis(), value));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 7,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_tokyo_endOfYear",
                            "test_body": "957: public void testParseInto_monthDay_feb29_tokyo_endOfYear() {\n958: DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n959: MutableDateTime result = new MutableDateTime(2004, 12, 31, 23, 59, 59, 999, TOKYO);\n960: assertEquals(4, f.parseInto(result, \"2 29\", 0));\n961: assertEquals(new MutableDateTime(2004, 2, 29, 23, 59, 59, 999, TOKYO), result);\n962: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nint defaultYear = chrono.year().get(instantLocal);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n} catch (IllegalFieldValueException e) {\nif (text != null) {\ne.prependMessage(\"Cannot parse \\\"\" + text + '\"');\nthrow e;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\n(iField.getRangeDurationField(), other.getRangeDurationField());\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.IllegalFieldValueException:prependMessage(Ljava/lang/String;)V",
                                    "method_body": "public void prependMessage(String message) {\nif (iMessage == null) {\n} else if (message != null) {\niMessage = message + \": \" + iMessage;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29_newYork_startOfYear",
                            "test_body": "929: public void testParseInto_monthDay_feb29_newYork_startOfYear() {\n930: DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n931: MutableDateTime result = new MutableDateTime(2004, 1, 1, 0, 0, 0, 0, NEWYORK);\n932: assertEquals(4, f.parseInto(result, \"2 29\", 0));\n933: assertEquals(new MutableDateTime(2004, 2, 29, 0, 0, 0, 0, NEWYORK), result);\n934: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nint defaultYear = chrono.year().get(instantLocal);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n} catch (IllegalFieldValueException e) {\nif (text != null) {\ne.prependMessage(\"Cannot parse \\\"\" + text + '\"');\nthrow e;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\n(iField.getRangeDurationField(), other.getRangeDurationField());\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.IllegalFieldValueException:prependMessage(Ljava/lang/String;)V",
                                    "method_body": "public void prependMessage(String message) {\nif (iMessage == null) {\n} else if (message != null) {\niMessage = message + \": \" + iMessage;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuilder buf = new StringBuilder();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int",
                            "test_body": "303: public void testForOffsetHoursMinutes_int_int() {\n304: assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n305: assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n306: 307: assertEquals(DateTimeZone.forID(\"+02:15\"), DateTimeZone.forOffsetHoursMinutes(2, 15));\n308: assertEquals(DateTimeZone.forID(\"+02:00\"), DateTimeZone.forOffsetHoursMinutes(2, 0));\n309: try {\n310: DateTimeZone.forOffsetHoursMinutes(2, -15);\n311: fail();\n312: } catch (IllegalArgumentException ex) {}\n313: 314: assertEquals(DateTimeZone.forID(\"+00:15\"), DateTimeZone.forOffsetHoursMinutes(0, 15));\n315: assertEquals(DateTimeZone.forID(\"+00:00\"), DateTimeZone.forOffsetHoursMinutes(0, 0));\n316: assertEquals(DateTimeZone.forID(\"-00:15\"), DateTimeZone.forOffsetHoursMinutes(0, -15));\n317: 318: assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n319: assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, -15));\n320: assertEquals(DateTimeZone.forID(\"-02:15\"), DateTimeZone.forOffsetHoursMinutes(-2, 15));\n321: 322: assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n323: try {\n324: DateTimeZone.forOffsetHoursMinutes(2, 60);\n325: fail();\n326: } catch (IllegalArgumentException ex) {}\n327: try {\n328: DateTimeZone.forOffsetHoursMinutes(-2, 60);\n329: fail();\n330: } catch (IllegalArgumentException ex) {}\n331: try {\n332: DateTimeZone.forOffsetHoursMinutes(24, 0);\n333: fail();\n334: } catch (IllegalArgumentException ex) {}\n335: try {\n336: DateTimeZone.forOffsetHoursMinutes(-24, 0);\n337: fail();\n338: } catch (IllegalArgumentException ex) {}\n339: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nint offset = parseOffset(id);\nif (offset == 0L) {\nreturn DateTimeZone.UTC;\nid = printOffset(offset);\nreturn fixedOffsetZone(id, offset);\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nreturn DateTimeZone.UTC;\nif (hoursOffset < -23 || hoursOffset > 23) {\nif (minutesOffset < 0 || minutesOffset > 59) {\nthrow new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\nint offset = 0;\nint hoursInMinutes = hoursOffset * 60;\nif (hoursInMinutes < 0) {\nminutesOffset = hoursInMinutes + minutesOffset;\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n}\nreturn forOffsetMillis(offset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nif (millisOffset < -MAX_MILLIS || millisOffset > MAX_MILLIS) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = ref.get();\nif (zone != null) {\nreturn zone;\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nSystem.getProperty(\"org.joda.time.DateTimeZone.Provider\");\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:parseOffset(Ljava/lang/String;)I",
                                    "method_body": "private static int parseOffset(String str) {\nChronology chrono = new BaseChronology() {\nreturn -(int) offsetFormatter().withChronology(chrono).parseMillis(str);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nbuf.append('-');\noffset = -offset;\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:offsetFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static synchronized DateTimeFormatter offsetFormatter() {\nif (cOffsetFormatter == null) {\ncOffsetFormatter = new DateTimeFormatterBuilder()\n.appendTimeZoneOffset(null, true, 2, 4)\n.toFormatter();\nreturn cOffsetFormatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
                                    "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nreturn (int) total;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseMillis(Ljava/lang/String;)J",
                                    "method_body": "public long parseMillis(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(iChrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn bucket.computeMillis(true, text);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nif (resetFields) {\nfor (int i = 0; i < count; i++) {\n}\nif (iOffset != null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int",
                            "test_body": "303: public void testForOffsetHoursMinutes_int_int() {\n304: assertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\n305: assertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\n306: assertEquals(DateTimeZone.forID(\"+03:15\"), DateTimeZone.forOffsetHoursMinutes(3, 15));\n307: assertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\n308: assertEquals(DateTimeZone.forID(\"-02:30\"), DateTimeZone.forOffsetHoursMinutes(-2, 30));\n309: assertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\n310: try {\n311: DateTimeZone.forOffsetHoursMinutes(2, 60);\n312: fail();\n313: } catch (IllegalArgumentException ex) {}\n314: try {\n315: DateTimeZone.forOffsetHoursMinutes(-2, 60);\n316: fail();\n317: } catch (IllegalArgumentException ex) {}\n318: try {\n319: DateTimeZone.forOffsetHoursMinutes(2, -1);\n320: fail();\n321: } catch (IllegalArgumentException ex) {}\n322: try {\n323: DateTimeZone.forOffsetHoursMinutes(-2, -1);\n324: fail();\n325: } catch (IllegalArgumentException ex) {}\n326: try {\n327: DateTimeZone.forOffsetHoursMinutes(24, 0);\n328: fail();\n329: } catch (IllegalArgumentException ex) {}\n330: try {\n331: DateTimeZone.forOffsetHoursMinutes(-24, 0);\n332: fail();\n333: } catch (IllegalArgumentException ex) {}\n334: }        \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\nthrow new IllegalArgumentException(\"Id must not be null\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n// ignored\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ntemp = UTC;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nreturn getDefault();\nreturn DateTimeZone.UTC;\nif (zone != null) {\nreturn zone;\n}\nint offset = parseOffset(id);\nif (offset == 0L) {\nreturn DateTimeZone.UTC;\nreturn fixedOffsetZone(id, offset);\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nreturn DateTimeZone.UTC;\n}\nthrow new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n}\ntry {\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n} else {\n}\n} catch (ArithmeticException ex) {\nreturn forOffsetMillis(offset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nreturn getDefault();\nif (id.equals(\"UTC\")) {\nreturn DateTimeZone.UTC;\nString convId = getConvertedId(id);\nif (convId != null) {\ndtz = cProvider.getZone(convId);\ndtz = cProvider.getZone(id);\n}\nreturn dtz;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nreturn DateTimeZone.UTC;\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n}\nif (ref != null) {\nzone = ref.get();\nif (zone != null) {\nreturn zone;\n}\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nprovider = getDefaultProvider();\n}\nif (ids == null || ids.size() == 0) {\nthrow new IllegalArgumentException\nthrow new IllegalArgumentException(\"The provider doesn't support UTC\");\nthrow new IllegalArgumentException(\"Invalid UTC zone provided\");\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\n\nSystem.getProperty(\"org.joda.time.DateTimeZone.Provider\");\nif (providerClass != null) {\ntry {\n\ntry {\n} catch (Exception ex) {\n}\nprovider = new UTCProvider();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nnameProvider = getDefaultNameProvider();\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\ntry {\nif (providerClass != null) {\ntry {\n\nnameProvider = new DefaultNameProvider();\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nif (map == null) {\n// Backwards compatibility with TimeZone.\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:parseOffset(Ljava/lang/String;)I",
                                    "method_body": "private static int parseOffset(String str) {\npublic DateTimeZone getZone() {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nif (offset >= 0) {\nbuf.append('+');\n} else {\noffset = -offset;\n}\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:offsetFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static synchronized DateTimeFormatter offsetFormatter() {\ncOffsetFormatter = new DateTimeFormatterBuilder()\n.appendTimeZoneOffset(null, true, 2, 4)\n.toFormatter();\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
                                    "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nreturn (int) total;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseMillis(Ljava/lang/String;)J",
                                    "method_body": "public long parseMillis(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(iChrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn bucket.computeMillis(true, text);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nif (resetFields) {\nfor (int i = 0; i < count; i++) {\n}\nif (iOffset != null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestMonths.testFactory_monthsBetween_RPartial_MonthDay",
                            "test_body": "130: public void testFactory_monthsBetween_RPartial_MonthDay() {\n131: MonthDay start = new MonthDay(2, 1);\n132: MonthDay end1 = new MonthDay(2, 28);\n133: MonthDay end2 = new MonthDay(2, 29);\n134: MonthDay end3 = new MonthDay(3, 1);\n135: 136: assertEquals(0, Months.monthsBetween(start, end1).getMonths());\n137: assertEquals(0, Months.monthsBetween(start, end2).getMonths());\n138: assertEquals(1, Months.monthsBetween(start, end3).getMonths());\n139: 140: assertEquals(0, Months.monthsBetween(end1, start).getMonths());\n141: assertEquals(0, Months.monthsBetween(end2, start).getMonths());\n142: assertEquals(-1, Months.monthsBetween(end3, start).getMonths());\n143: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:isContiguous(Lorg/joda/time/ReadablePartial;)Z",
                                    "method_body": "public static final boolean isContiguous(ReadablePartial partial) {\nif (partial == null) {\nDurationFieldType lastType = null;\nfor (int i = 0; i < partial.size(); i++) {\nDateTimeField loopField = partial.getField(i);\nif (i > 0) {\nif (loopField.getRangeDurationField().getType() != lastType) {\nlastType = loopField.getDurationField().getType();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(II)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth) {\nthis(monthOfYear, dayOfMonth, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:<init>(I)V",
                                    "method_body": "protected BaseSingleFieldPeriod(int period) {\nsuper();\niPeriod = period;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:between(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePeriod;)I",
                                    "method_body": "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\nif (start == null || end == null) {\nif (start.size() != end.size()) {\nfor (int i = 0, isize = start.size(); i < isize; i++) {\nif (start.getFieldType(i) != end.getFieldType(i)) {\nif (DateTimeUtils.isContiguous(start) == false) {\nChronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\nint[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\nreturn values[0];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:getValue()I",
                                    "method_body": "protected int getValue() {\nreturn iPeriod;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:size()I",
                                    "method_body": "public abstract DurationFieldType getFieldType();\nreturn 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:getFieldType(I)Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public DurationFieldType getFieldType(int index) {\nif (index != 0) {\nreturn getFieldType();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Months:<init>(I)V",
                                    "method_body": "private Months(int months) {\nsuper(months);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Months:months(I)Lorg/joda/time/Months;",
                                    "method_body": "public static Months months(int months) {\nswitch (months) {\nreturn ZERO;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Months:monthsBetween(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;)Lorg/joda/time/Months;",
                                    "method_body": "public static Months monthsBetween(ReadablePartial start, ReadablePartial end) {\nif (start instanceof LocalDate && end instanceof LocalDate)   {\nint amount = BaseSingleFieldPeriod.between(start, end, ZERO);\nreturn Months.months(amount);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Months:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getValue();\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDays.testFactory_daysBetween_RPartial_MonthDay",
                            "test_body": "123: public void testFactory_daysBetween_RPartial_MonthDay() {\n124: MonthDay start1 = new MonthDay(2, 1);\n125: MonthDay start2 = new MonthDay(2, 28);\n126: MonthDay end1 = new MonthDay(2, 28);\n127: MonthDay end2 = new MonthDay(2, 29);\n128: 129: assertEquals(27, Days.daysBetween(start1, end1).getDays());\n130: assertEquals(28, Days.daysBetween(start1, end2).getDays());\n131: assertEquals(0, Days.daysBetween(start2, end1).getDays());\n132: assertEquals(1, Days.daysBetween(start2, end2).getDays());\n133: 134: assertEquals(-27, Days.daysBetween(end1, start1).getDays());\n135: assertEquals(-28, Days.daysBetween(end2, start1).getDays());\n136: assertEquals(0, Days.daysBetween(end1, start2).getDays());\n137: assertEquals(-1, Days.daysBetween(end2, start2).getDays());\n138: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:isContiguous(Lorg/joda/time/ReadablePartial;)Z",
                                    "method_body": "public static final boolean isContiguous(ReadablePartial partial) {\nif (partial == null) {\nDurationFieldType lastType = null;\nfor (int i = 0; i < partial.size(); i++) {\nDateTimeField loopField = partial.getField(i);\nif (i > 0) {\nif (loopField.getRangeDurationField().getType() != lastType) {\nlastType = loopField.getDurationField().getType();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.contains(null) || printerList.isEmpty()) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.contains(null) || parserList.isEmpty()) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(II)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth) {\nthis(monthOfYear, dayOfMonth, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:<init>(I)V",
                                    "method_body": "protected BaseSingleFieldPeriod(int period) {\nsuper();\niPeriod = period;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:between(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePeriod;)I",
                                    "method_body": "protected static int between(ReadablePartial start, ReadablePartial end, ReadablePeriod zeroInstance) {\nif (start == null || end == null) {\nif (start.size() != end.size()) {\nfor (int i = 0, isize = start.size(); i < isize; i++) {\nif (start.getFieldType(i) != end.getFieldType(i)) {\nif (DateTimeUtils.isContiguous(start) == false) {\nChronology chrono = DateTimeUtils.getChronology(start.getChronology()).withUTC();\nint[] values = chrono.get(zeroInstance, chrono.set(start, 0L), chrono.set(end, 0L));\nreturn values[0];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:getValue()I",
                                    "method_body": "protected int getValue() {\nreturn iPeriod;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:size()I",
                                    "method_body": "public abstract DurationFieldType getFieldType();\nreturn 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.base.BaseSingleFieldPeriod:getFieldType(I)Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public DurationFieldType getFieldType(int index) {\nif (index != 0) {\nreturn getFieldType();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Days:<init>(I)V",
                                    "method_body": "private Days(int days) {\nsuper(days);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Days:days(I)Lorg/joda/time/Days;",
                                    "method_body": "public static Days days(int days) {\nswitch (days) {\nreturn new Days(days);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Days:daysBetween(Lorg/joda/time/ReadablePartial;Lorg/joda/time/ReadablePartial;)Lorg/joda/time/Days;",
                                    "method_body": "public static Days daysBetween(ReadablePartial start, ReadablePartial end) {\nif (start instanceof LocalDate && end instanceof LocalDate)   {\nint amount = BaseSingleFieldPeriod.between(start, end, ZERO);\nreturn Days.days(amount);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Days:getDays()I",
                                    "method_body": "public int getDays() {\nreturn getValue();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero3",
                            "test_body": "120: public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n121: GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n122: cal.set(Calendar.ERA, GregorianCalendar.BC);\n123: cal.set(Calendar.MILLISECOND, 7);\n124: LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n125: assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n126: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIII)V",
                                    "method_body": "public LocalDateTime(\nthis(year, monthOfYear, dayOfMonth, hourOfDay,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:size()I",
                                    "method_body": "public int size() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.year();\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\nreturn chrono.millisOfDay();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getValue(I)I",
                                    "method_body": "public int getValue(int index) {\nswitch (index) {\nreturn getChronology().year().get(getLocalMillis());\nreturn getChronology().monthOfYear().get(getLocalMillis());\nreturn getChronology().dayOfMonth().get(getLocalMillis());\nreturn getChronology().millisOfDay().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDateTime) {\nLocalDateTime other = (LocalDateTime) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:fromCalendarFields(Ljava/util/Calendar;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\nif (calendar == null) {\nint yearOfEra = calendar.get(Calendar.YEAR);\nreturn new LocalDateTime(\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero1",
                            "test_body": "150: public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n151: GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n152: cal.set(Calendar.ERA, GregorianCalendar.BC);\n153: cal.set(Calendar.MILLISECOND, 7);\n154: LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n155: assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n156: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIII)V",
                                    "method_body": "public LocalDateTime(\nthis(year, monthOfYear, dayOfMonth, hourOfDay,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:fromDateFields(Ljava/util/Date;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public static LocalDateTime fromDateFields(Date date) {\nif (date == null) {\nreturn new LocalDateTime(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:size()I",
                                    "method_body": "public int size() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.year();\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\nreturn chrono.millisOfDay();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getValue(I)I",
                                    "method_body": "public int getValue(int index) {\nswitch (index) {\nreturn getChronology().year().get(getLocalMillis());\nreturn getChronology().monthOfYear().get(getLocalMillis());\nreturn getChronology().dayOfMonth().get(getLocalMillis());\nreturn getChronology().millisOfDay().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDateTime) {\nLocalDateTime other = (LocalDateTime) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDateTime_Constructors.testFactory_fromCalendarFields_beforeYearZero1",
                            "test_body": "112: public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n113: GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n114: cal.set(Calendar.ERA, GregorianCalendar.BC);\n115: cal.set(Calendar.MILLISECOND, 7);\n116: LocalDateTime expected = new LocalDateTime(0, 2, 3, 4, 5, 6, 7);\n117: assertEquals(expected, LocalDateTime.fromCalendarFields(cal));\n118: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIII)V",
                                    "method_body": "public LocalDateTime(\nthis(year, monthOfYear, dayOfMonth, hourOfDay,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:size()I",
                                    "method_body": "public int size() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.year();\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\nreturn chrono.millisOfDay();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getValue(I)I",
                                    "method_body": "public int getValue(int index) {\nswitch (index) {\nreturn getChronology().year().get(getLocalMillis());\nreturn getChronology().monthOfYear().get(getLocalMillis());\nreturn getChronology().dayOfMonth().get(getLocalMillis());\nreturn getChronology().millisOfDay().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDateTime) {\nLocalDateTime other = (LocalDateTime) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:fromCalendarFields(Ljava/util/Calendar;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public static LocalDateTime fromCalendarFields(Calendar calendar) {\nif (calendar == null) {\nint yearOfEra = calendar.get(Calendar.YEAR);\nreturn new LocalDateTime(\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDateTime_Constructors.testFactory_fromDateFields_beforeYearZero3",
                            "test_body": "158: public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n159: GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n160: cal.set(Calendar.ERA, GregorianCalendar.BC);\n161: cal.set(Calendar.MILLISECOND, 7);\n162: LocalDateTime expected = new LocalDateTime(-2, 2, 3, 4, 5, 6, 7);\n163: assertEquals(expected, LocalDateTime.fromDateFields(cal.getTime()));\n164: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIII)V",
                                    "method_body": "public LocalDateTime(\nthis(year, monthOfYear, dayOfMonth, hourOfDay,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:fromDateFields(Ljava/util/Date;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public static LocalDateTime fromDateFields(Date date) {\nif (date == null) {\nreturn new LocalDateTime(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:size()I",
                                    "method_body": "public int size() {\nreturn 4;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.year();\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\nreturn chrono.millisOfDay();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getValue(I)I",
                                    "method_body": "public int getValue(int index) {\nswitch (index) {\nreturn getChronology().year().get(getLocalMillis());\nreturn getChronology().monthOfYear().get(getLocalMillis());\nreturn getChronology().dayOfMonth().get(getLocalMillis());\nreturn getChronology().millisOfDay().get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDateTime) {\nLocalDateTime other = (LocalDateTime) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero3",
                            "test_body": "112: public void testFactory_fromCalendarFields_beforeYearZero3() throws Exception {\n113: GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n114: cal.set(Calendar.ERA, GregorianCalendar.BC);\n115: cal.set(Calendar.MILLISECOND, 7);\n116: LocalDate expected = new LocalDate(-2, 2, 3);\n117: assertEquals(expected, LocalDate.fromCalendarFields(cal));\n118: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(III)V",
                                    "method_body": "public LocalDate(\nthis(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = -8775358157899L;\nprivate static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\nDATE_DURATION_TYPES.add(DurationFieldType.days());\nDATE_DURATION_TYPES.add(DurationFieldType.weeks());\nDATE_DURATION_TYPES.add(DurationFieldType.months());\nDATE_DURATION_TYPES.add(DurationFieldType.weekyears());\nDATE_DURATION_TYPES.add(DurationFieldType.years());\nDATE_DURATION_TYPES.add(DurationFieldType.centuries());\nDATE_DURATION_TYPES.add(DurationFieldType.eras());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nif (isSupported(fieldType) == false) {\nreturn fieldType.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nDurationFieldType durType = type.getDurationType();\nif (DATE_DURATION_TYPES.contains(durType) ||\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDate) {\nLocalDate other = (LocalDate) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.date().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:fromCalendarFields(Ljava/util/Calendar;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public static LocalDate fromCalendarFields(Calendar calendar) {\nif (calendar == null) {\nint yearOfEra = calendar.get(Calendar.YEAR);\nreturn new LocalDate(\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero1",
                            "test_body": "142: public void testFactory_fromDateFields_beforeYearZero1() throws Exception {\n143: GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n144: cal.set(Calendar.ERA, GregorianCalendar.BC);\n145: cal.set(Calendar.MILLISECOND, 7);\n146: LocalDate expected = new LocalDate(0, 2, 3);\n147: assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n148: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(III)V",
                                    "method_body": "public LocalDate(\nthis(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = -8775358157899L;\nprivate static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\nDATE_DURATION_TYPES.add(DurationFieldType.days());\nDATE_DURATION_TYPES.add(DurationFieldType.weeks());\nDATE_DURATION_TYPES.add(DurationFieldType.months());\nDATE_DURATION_TYPES.add(DurationFieldType.weekyears());\nDATE_DURATION_TYPES.add(DurationFieldType.years());\nDATE_DURATION_TYPES.add(DurationFieldType.centuries());\nDATE_DURATION_TYPES.add(DurationFieldType.eras());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:fromDateFields(Ljava/util/Date;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public static LocalDate fromDateFields(Date date) {\nif (date == null) {\nreturn new LocalDate(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nif (isSupported(fieldType) == false) {\nreturn fieldType.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nDurationFieldType durType = type.getDurationType();\nif (DATE_DURATION_TYPES.contains(durType) ||\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDate) {\nLocalDate other = (LocalDate) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.date().print(this);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDate_Constructors.testFactory_fromCalendarFields_beforeYearZero1",
                            "test_body": "104: public void testFactory_fromCalendarFields_beforeYearZero1() throws Exception {\n105: GregorianCalendar cal = new GregorianCalendar(1, 1, 3, 4, 5, 6);\n106: cal.set(Calendar.ERA, GregorianCalendar.BC);\n107: cal.set(Calendar.MILLISECOND, 7);\n108: LocalDate expected = new LocalDate(0, 2, 3);\n109: assertEquals(expected, LocalDate.fromCalendarFields(cal));\n110: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(III)V",
                                    "method_body": "public LocalDate(\nthis(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = -8775358157899L;\nprivate static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\nDATE_DURATION_TYPES.add(DurationFieldType.days());\nDATE_DURATION_TYPES.add(DurationFieldType.weeks());\nDATE_DURATION_TYPES.add(DurationFieldType.months());\nDATE_DURATION_TYPES.add(DurationFieldType.weekyears());\nDATE_DURATION_TYPES.add(DurationFieldType.years());\nDATE_DURATION_TYPES.add(DurationFieldType.centuries());\nDATE_DURATION_TYPES.add(DurationFieldType.eras());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nif (isSupported(fieldType) == false) {\nreturn fieldType.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nDurationFieldType durType = type.getDurationType();\nif (DATE_DURATION_TYPES.contains(durType) ||\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDate) {\nLocalDate other = (LocalDate) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.date().print(this);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:fromCalendarFields(Ljava/util/Calendar;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public static LocalDate fromCalendarFields(Calendar calendar) {\nif (calendar == null) {\nint yearOfEra = calendar.get(Calendar.YEAR);\nreturn new LocalDate(\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestLocalDate_Constructors.testFactory_fromDateFields_beforeYearZero3",
                            "test_body": "150: public void testFactory_fromDateFields_beforeYearZero3() throws Exception {\n151: GregorianCalendar cal = new GregorianCalendar(3, 1, 3, 4, 5, 6);\n152: cal.set(Calendar.ERA, GregorianCalendar.BC);\n153: cal.set(Calendar.MILLISECOND, 7);\n154: LocalDate expected = new LocalDate(-2, 2, 3);\n155: assertEquals(expected, LocalDate.fromDateFields(cal.getTime()));\n156: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(III)V",
                                    "method_body": "public LocalDate(\nthis(year, monthOfYear, dayOfMonth, ISOChronology.getInstanceUTC());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = -8775358157899L;\nprivate static final Set<DurationFieldType> DATE_DURATION_TYPES = new HashSet<DurationFieldType>();\nDATE_DURATION_TYPES.add(DurationFieldType.days());\nDATE_DURATION_TYPES.add(DurationFieldType.weeks());\nDATE_DURATION_TYPES.add(DurationFieldType.months());\nDATE_DURATION_TYPES.add(DurationFieldType.weekyears());\nDATE_DURATION_TYPES.add(DurationFieldType.years());\nDATE_DURATION_TYPES.add(DurationFieldType.centuries());\nDATE_DURATION_TYPES.add(DurationFieldType.eras());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:fromDateFields(Ljava/util/Date;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public static LocalDate fromDateFields(Date date) {\nif (date == null) {\nreturn new LocalDate(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:get(Lorg/joda/time/DateTimeFieldType;)I",
                                    "method_body": "public int get(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nif (isSupported(fieldType) == false) {\nreturn fieldType.getField(getChronology()).get(getLocalMillis());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
                                    "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nDurationFieldType durType = type.getDurationType();\nif (DATE_DURATION_TYPES.contains(durType) ||\nreturn type.getField(getChronology()).isSupported();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object partial) {\nif (this == partial) {\nif (partial instanceof LocalDate) {\nLocalDate other = (LocalDate) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn ISODateTimeFormat.date().print(this);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestISOPeriodFormat.testFormatStandard_negative",
                            "test_body": "118: public void testFormatStandard_negative() {\n119: Period p = new Period(-1, -2, -3, -4, -5, -6, -7, -8);\n120: assertEquals(\"P-1Y-2M-3W-4DT-5H-6M-7.008S\", ISOPeriodFormat.standard().print(p));\n121: 122: p = Period.years(-54);\n123: assertEquals(\"P-54Y\", ISOPeriodFormat.standard().print(p));\n124: 125: p = Period.seconds(4).withMillis(-8);\n126: assertEquals(\"PT3.992S\", ISOPeriodFormat.standard().print(p));\n127: 128: p = Period.seconds(-4).withMillis(8);\n129: assertEquals(\"PT-3.992S\", ISOPeriodFormat.standard().print(p));\n130: 131: p = Period.seconds(-23);\n132: assertEquals(\"PT-23S\", ISOPeriodFormat.standard().print(p));\n133: 134: p = Period.millis(-8);\n135: assertEquals(\"PT-0.008S\", ISOPeriodFormat.standard().print(p));\n136: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:minutes()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType minutes() {\nreturn MINUTES_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:hours()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType hours() {\nreturn HOURS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:weeks()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType weeks() {\nreturn WEEKS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISOPeriodFormat:standard()Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "public static PeriodFormatter standard() {\nif (cStandard == null) {\ncStandard = new PeriodFormatterBuilder()\nreturn cStandard;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:<init>()V",
                                    "method_body": "public PeriodFormatterBuilder() {\nclear();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter()Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "public PeriodFormatter toFormatter() {\nPeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\niFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendLiteral(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendLiteral(String text) {\nif (text == null) {\nclearPrefix();\nLiteral literal = new Literal(text);\nappend0(literal, literal);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendYears()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendYears() {\nappendField(YEARS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMonths()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendMonths() {\nappendField(MONTHS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendWeeks()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendWeeks() {\nappendField(WEEKS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendDays()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendDays() {\nappendField(DAYS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendHours()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendHours() {\nappendField(HOURS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMinutes()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendMinutes() {\nappendField(MINUTES);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSecondsWithOptionalMillis()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\nappendField(SECONDS_OPTIONAL_MILLIS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(I)V",
                                    "method_body": "private void appendField(int type) {\nappendField(type, iMinPrintedDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(II)V",
                                    "method_body": "private void appendField(int type, int minPrinted) {\nFieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\nappend0(field, field);\niFieldFormatters[type] = field;\niPrefix = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSuffix(String text) {\nif (text == null) {\nreturn appendSuffix(new SimpleAffix(text));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\nif (iElementPairs.size() > 0) {\noriginalPrinter = iElementPairs.get(iElementPairs.size() - 2);\noriginalParser = iElementPairs.get(iElementPairs.size() - 1);\nif (originalPrinter == null || originalParser == null ||\nclearPrefix();\nFieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\niElementPairs.set(iElementPairs.size() - 2, newField);\niElementPairs.set(iElementPairs.size() - 1, newField);\niFieldFormatters[newField.getFieldType()] = newField;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparatorIfFieldsAfter(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\nreturn appendSeparator(text, text, null, false, true);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparator(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;ZZ)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder appendSeparator(String text, String finalText,\nif (text == null || finalText == null) {\nclearPrefix();\nList<Object> pairs = iElementPairs;\nif (pairs.size() == 0) {\nSeparator lastSeparator = null;\nfor (i=pairs.size(); --i>=0; ) {\nif (pairs.get(i) instanceof Separator) {\ni--;  // element pairs\nif (lastSeparator != null && pairs.size() == 0) {\nObject[] comp = createComposite(pairs);\npairs.clear();\nSeparator separator = new Separator(\npairs.add(separator);\npairs.add(separator);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:clearPrefix()V",
                                    "method_body": "private void clearPrefix() throws IllegalStateException {\nif (iPrefix != null) {\niPrefix = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:append0(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\niElementPairs.add(printer);\niElementPairs.add(parser);\niNotPrinter |= (printer == null);\niNotParser |= (parser == null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter(Ljava/util/List;ZZ)Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\nif (notPrinter && notParser) {\nint size = elementPairs.size();\nif (size >= 2 && elementPairs.get(0) instanceof Separator) {\nSeparator sep = (Separator) elementPairs.get(0);\nif (sep.iAfterParser == null && sep.iAfterPrinter == null) {\nPeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\nsep = sep.finish(f.getPrinter(), f.getParser());\nreturn new PeriodFormatter(sep, sep);\nObject[] comp = createComposite(elementPairs);\nif (notPrinter) {\n} else if (notParser) {\nreturn new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:createComposite(Ljava/util/List;)[Ljava/lang/Object;",
                                    "method_body": "private static Object[] createComposite(List<Object> elementPairs) {\nswitch (elementPairs.size()) {\nComposite comp = new Composite(elementPairs);\nreturn new Object[] {comp, comp};\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Literal:<init>(Ljava/lang/String;)V",
                                    "method_body": "Literal(String text) {\niText = text;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(IIIZI[Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
                                    "method_body": "FieldFormatter(int minPrintedDigits, int printZeroSetting,\nPeriodFieldAffix prefix, PeriodFieldAffix suffix) {\niMinPrintedDigits = minPrintedDigits;\niPrintZeroSetting = printZeroSetting;\niMaxParsedDigits = maxParsedDigits;\niRejectSignedValues = rejectSignedValues;\niFieldType = fieldType;\niFieldFormatters = fieldFormatters;\niPrefix = prefix;\niSuffix = suffix;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
                                    "method_body": "FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\niMinPrintedDigits = field.iMinPrintedDigits;\niPrintZeroSetting = field.iPrintZeroSetting;\niMaxParsedDigits = field.iMaxParsedDigits;\niRejectSignedValues = field.iRejectSignedValues;\niFieldType = field.iFieldType;\niFieldFormatters = field.iFieldFormatters;\niPrefix = field.iPrefix;\nif (field.iSuffix != null) {\niSuffix = suffix;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:countFieldsToPrint(Lorg/joda/time/ReadablePeriod;ILjava/util/Locale;)I",
                                    "method_body": "public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\nif (stopAt <= 0) {\nif (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\nreturn 1;\nreturn 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:calculatePrintedLength(Lorg/joda/time/ReadablePeriod;Ljava/util/Locale;)I",
                                    "method_body": "public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\nlong valueLong = getFieldValue(period);\nif (valueLong == Long.MAX_VALUE) {\nreturn 0;\nint sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\nif (iFieldType >= SECONDS_MILLIS) {\nsum = Math.max(sum, 4);\nsum++;\nif (iFieldType == SECONDS_OPTIONAL_MILLIS &&\nsum -= 4; // remove three digits and decimal point\nvalueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\nint value = (int) valueLong;\nif (iPrefix != null) {\nif (iSuffix != null) {\nsum += iSuffix.calculatePrintedLength(value);\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePeriod;Ljava/util/Locale;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\nlong valueLong = getFieldValue(period);\nif (valueLong == Long.MAX_VALUE) {\nreturn;\nint value = (int) valueLong;\nif (iFieldType >= SECONDS_MILLIS) {\nvalue = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\nif (iPrefix != null) {\nint minDigits = iMinPrintedDigits;\nif (minDigits <= 1) {\nFormatUtils.appendUnpaddedInteger(buf, value);\nif (iFieldType >= SECONDS_MILLIS) {\nint dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\nif (iFieldType == SECONDS_MILLIS || dp > 0) {\nbuf.append('.');\nFormatUtils.appendPaddedInteger(buf, dp, 3);\nif (iSuffix != null) {\niSuffix.printTo(buf, value);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:getFieldValue(Lorg/joda/time/ReadablePeriod;)J",
                                    "method_body": "long getFieldValue(ReadablePeriod period) {\nif (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\ntype = period.getPeriodType();\nif (type != null && isSupported(type, iFieldType) == false) {\nswitch (iFieldType) {\nvalue = period.get(DurationFieldType.years());\nbreak;\nvalue = period.get(DurationFieldType.months());\nbreak;\nvalue = period.get(DurationFieldType.weeks());\nbreak;\nvalue = period.get(DurationFieldType.days());\nbreak;\nvalue = period.get(DurationFieldType.hours());\nbreak;\nvalue = period.get(DurationFieldType.minutes());\nbreak;\nint seconds = period.get(DurationFieldType.seconds());\nint millis = period.get(DurationFieldType.millis());\nvalue = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\nif (value == 0) {\nswitch (iPrintZeroSetting) {\nif (isZero(period) && iFieldFormatters[iFieldType] == this) {\nreturn Long.MAX_VALUE;\nreturn value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:isZero(Lorg/joda/time/ReadablePeriod;)Z",
                                    "method_body": "boolean isZero(ReadablePeriod period) {\nfor (int i = 0, isize = period.size(); i < isize; i++) {\nif (period.getValue(i) != 0) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:isSupported(Lorg/joda/time/PeriodType;I)Z",
                                    "method_body": "boolean isSupported(PeriodType type, int field) {\nswitch (field) {\nreturn type.isSupported(DurationFieldType.years());\nreturn type.isSupported(DurationFieldType.months());\nreturn type.isSupported(DurationFieldType.weeks());\nreturn type.isSupported(DurationFieldType.days());\nreturn type.isSupported(DurationFieldType.hours());\nreturn type.isSupported(DurationFieldType.minutes());\nreturn type.isSupported(DurationFieldType.seconds()) ||\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:getFieldType()I",
                                    "method_body": "int getFieldType() {\nreturn iFieldType;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix:<init>(Ljava/lang/String;)V",
                                    "method_body": "int calculatePrintedLength(int value);\nSimpleAffix(String text) {\niText = text;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = printerList.toArray(\nif (parserList.size() <= 0) {\niParsers = parserList.toArray(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:<init>(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;ZZ)V",
                                    "method_body": "Separator(String text, String finalText, String[] variants,\nboolean useBefore, boolean useAfter) {\niText = text;\niFinalText = finalText;\nif ((finalText == null || text.equals(finalText)) &&\niParsedForms = new String[] {text};\niBeforePrinter = beforePrinter;\niBeforeParser = beforeParser;\niUseBefore = useBefore;\niUseAfter = useAfter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:finish(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder$Separator;",
                                    "method_body": "Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\niAfterPrinter = afterPrinter;\niAfterParser = afterParser;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:<init>(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)V",
                                    "method_body": "public PeriodFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niParseType = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:getPrinter()Lorg/joda/time/format/PeriodPrinter;",
                                    "method_body": "public PeriodPrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:getParser()Lorg/joda/time/format/PeriodParser;",
                                    "method_body": "public PeriodParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:print(Lorg/joda/time/ReadablePeriod;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadablePeriod period) {\ncheckPrinter();\ncheckPeriod(period);\nPeriodPrinter printer = getPrinter();\nStringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));\nprinter.printTo(buf, period, iLocale);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:checkPrinter()V",
                                    "method_body": "private void checkPrinter() {\nif (iPrinter == null) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:checkPeriod(Lorg/joda/time/ReadablePeriod;)V",
                                    "method_body": "private void checkPeriod(ReadablePeriod period) {\nif (period == null) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(IIIIIIII)V",
                                    "method_body": "public Period(int years, int months, int weeks, int days,\nsuper(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(IIIIIIIILorg/joda/time/PeriodType;)V",
                                    "method_body": "public Period(int years, int months, int weeks, int days,\nsuper(years, months, weeks, days, hours, minutes, seconds, millis, type);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>([ILorg/joda/time/PeriodType;)V",
                                    "method_body": "private Period(int[] values, PeriodType type) {\nsuper(values, type);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:years(I)Lorg/joda/time/Period;",
                                    "method_body": "public static Period years(int years) {\nreturn new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:seconds(I)Lorg/joda/time/Period;",
                                    "method_body": "public static Period seconds(int seconds) {\nreturn new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:millis(I)Lorg/joda/time/Period;",
                                    "method_body": "public static Period millis(int millis) {\nreturn new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:withMillis(I)Lorg/joda/time/Period;",
                                    "method_body": "public Period withMillis(int millis) {\nint[] values = getValues();  // cloned\ngetPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\nreturn new Period(values, getPeriodType());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
                                    "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\ncStandard = type;\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:setIndexedField(Lorg/joda/time/ReadablePeriod;I[II)Z",
                                    "method_body": "boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\nint realIndex = iIndices[index];\nif (realIndex == -1) {\nvalues[realIndex] = newValue;\nreturn true;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testPlusDays_int_fromLeap",
                            "test_body": "507: public void testPlusDays_int_fromLeap() {\n508: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n509: MonthDay result = test.plusDays(1);\n510: MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n511: assertEquals(expected, result);\n512: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:plusDays(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay plusDays(int days) {\nreturn withFieldAdded(DurationFieldType.days(), days);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testPlusMonths_int_negativeFromLeap",
                            "test_body": "458: public void testPlusMonths_int_negativeFromLeap() {\n459: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n460: MonthDay result = test.plusMonths(-1);\n461: MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n462: assertEquals(expected, result);\n463: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:plusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay plusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), months);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testPlusMonths_int_fromLeap",
                            "test_body": "451: public void testPlusMonths_int_fromLeap() {\n452: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n453: MonthDay result = test.plusMonths(1);\n454: MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n455: assertEquals(expected, result);\n456: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:plusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay plusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), months);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testMinusDays_int_negativeFromLeap",
                            "test_body": "608: public void testMinusDays_int_negativeFromLeap() {\n609: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n610: MonthDay result = test.minusDays(-1);\n611: MonthDay expected = new MonthDay(3, 1, ISOChronology.getInstance());\n612: assertEquals(expected, result);\n613: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
                                    "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:minusDays(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay minusDays(int days) {\nreturn withFieldAdded(DurationFieldType.days(), FieldUtils.safeNegate(days));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testMinusMonths_int_endOfMonthAdjust",
                            "test_body": "559: public void testMinusMonths_int_endOfMonthAdjust() {\n560: MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n561: MonthDay result = test.minusMonths(1);\n562: MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n563: assertEquals(expected, result);\n564: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(Lorg/joda/time/ReadablePartial;I[II)[I",
                                    "method_body": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\nif (valueToAdd == 0) {\nif (DateTimeUtils.isContiguous(partial)) {\nlong instant = 0L;\nfor (int i = 0, isize = partial.size(); i < isize; i++) {\ninstant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\ninstant = add(instant, valueToAdd);\nreturn iChronology.get(partial, instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
                                    "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(JI)J",
                                    "method_body": "public long add(long instant, int months) {\nif (months == 0) {\nlong timePart = iChronology.getMillisOfDay(instant);\nint thisYear = iChronology.getYear(instant);\nint thisMonth = iChronology.getMonthOfYear(instant, thisYear);\nint monthToUse = thisMonth - 1 + months;\nif (monthToUse >= 0) {\nyearToUse = thisYear + (monthToUse / iMax);\nmonthToUse = (monthToUse % iMax) + 1;\nint dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\nint maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\nif (dayToUse > maxDay) {\ndayToUse = maxDay;\nlong datePart =\nreturn datePart + timePart;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(Lorg/joda/time/MonthDay;[I)V",
                                    "method_body": "MonthDay(MonthDay partial, int[] values) {\nsuper(partial, values);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:minusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay minusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testPlusMonths_int_negativeEndOfMonthAdjust",
                            "test_body": "472: public void testPlusMonths_int_negativeEndOfMonthAdjust() {\n473: MonthDay test = new MonthDay(3, 31, ISOChronology.getInstanceUTC());\n474: MonthDay result = test.plusMonths(-1);\n475: MonthDay expected = new MonthDay(2, 29, ISOChronology.getInstance());\n476: assertEquals(expected, result);\n477: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(Lorg/joda/time/ReadablePartial;I[II)[I",
                                    "method_body": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\nif (valueToAdd == 0) {\nif (DateTimeUtils.isContiguous(partial)) {\nlong instant = 0L;\nfor (int i = 0, isize = partial.size(); i < isize; i++) {\ninstant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\ninstant = add(instant, valueToAdd);\nreturn iChronology.get(partial, instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:plusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay plusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), months);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(JI)J",
                                    "method_body": "public long add(long instant, int months) {\nif (months == 0) {\nlong timePart = iChronology.getMillisOfDay(instant);\nint thisYear = iChronology.getYear(instant);\nint thisMonth = iChronology.getMonthOfYear(instant, thisYear);\nint monthToUse = thisMonth - 1 + months;\nif (monthToUse >= 0) {\nyearToUse = thisYear + (monthToUse / iMax);\nmonthToUse = (monthToUse % iMax) + 1;\nint dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\nint maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\nif (dayToUse > maxDay) {\ndayToUse = maxDay;\nlong datePart =\nreturn datePart + timePart;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(Lorg/joda/time/MonthDay;[I)V",
                                    "method_body": "MonthDay(MonthDay partial, int[] values) {\nsuper(partial, values);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testMinusMonths_int_fromLeap",
                            "test_body": "545: public void testMinusMonths_int_fromLeap() {\n546: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n547: MonthDay result = test.minusMonths(1);\n548: MonthDay expected = new MonthDay(1, 29, ISOChronology.getInstance());\n549: assertEquals(expected, result);\n550: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
                                    "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:minusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay minusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestMonthDay_Basics.testMinusMonths_int_negativeFromLeap",
                            "test_body": "552: public void testMinusMonths_int_negativeFromLeap() {\n553: MonthDay test = new MonthDay(2, 29, ISOChronology.getInstanceUTC());\n554: MonthDay result = test.minusMonths(-1);\n555: MonthDay expected = new MonthDay(3, 29, ISOChronology.getInstance());\n556: assertEquals(expected, result);\n557: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:<init>(Lorg/joda/time/chrono/BasicChronology;I)V",
                                    "method_body": "BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\nsuper(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\niChronology = chronology;\niMax = iChronology.getMaxMonth();\niLeapMonth = leapMonth;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\nint thisYear = iChronology.getYear(instant);\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
                                    "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMinimumValue()I",
                                    "method_body": "public int getMinimumValue() {\nreturn MIN;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getMaximumValue()I",
                                    "method_body": "public int getMaximumValue() {\nreturn iMax;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nf = parser;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:<init>(IILorg/joda/time/Chronology;)V",
                                    "method_body": "public MonthDay(int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(new int[] {monthOfYear, dayOfMonth}, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:getField(ILorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
                                    "method_body": "protected DateTimeField getField(int index, Chronology chrono) {\nswitch (index) {\nreturn chrono.monthOfYear();\nreturn chrono.dayOfMonth();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:withFieldAdded(Lorg/joda/time/DurationFieldType;I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay withFieldAdded(DurationFieldType fieldType, int amount) {\nint index = indexOfSupported(fieldType);\nif (amount == 0) {\nint[] newValues = getValues();\nnewValues = getField(index).add(this, index, newValues, amount);\nreturn new MonthDay(this, newValues);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeNegate(I)I",
                                    "method_body": "public static int safeNegate(int value) {\nif (value == Integer.MIN_VALUE) {\nreturn -value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MonthDay:minusMonths(I)Lorg/joda/time/MonthDay;",
                                    "method_body": "public MonthDay minusMonths(int months) {\nreturn withFieldAdded(DurationFieldType.months(), FieldUtils.safeNegate(months));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.joda.time.field.TestFieldUtils.testSafeMultiplyLongInt",
                            "test_body": "241: public void testSafeMultiplyLongInt() {\n242: assertEquals(0L, FieldUtils.safeMultiply(0L, 0));\n243: 244: assertEquals(1L, FieldUtils.safeMultiply(1L, 1));\n245: assertEquals(3L, FieldUtils.safeMultiply(1L, 3));\n246: assertEquals(3L, FieldUtils.safeMultiply(3L, 1));\n247: 248: assertEquals(6L, FieldUtils.safeMultiply(2L, 3));\n249: assertEquals(-6L, FieldUtils.safeMultiply(2L, -3));\n250: assertEquals(-6L, FieldUtils.safeMultiply(-2L, 3));\n251: assertEquals(6L, FieldUtils.safeMultiply(-2L, -3));\n252: 253: assertEquals(-1L * Integer.MIN_VALUE, FieldUtils.safeMultiply(-1L, Integer.MIN_VALUE));\n254: 255: assertEquals(Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, 1));\n256: assertEquals(Long.MIN_VALUE, FieldUtils.safeMultiply(Long.MIN_VALUE, 1));\n257: assertEquals(-Long.MAX_VALUE, FieldUtils.safeMultiply(Long.MAX_VALUE, -1));\n258: 259: try {\n260: FieldUtils.safeMultiply(Long.MIN_VALUE, -1);\n261: fail();\n262: } catch (ArithmeticException e) {\n263: }\n264: 265: try {\n266: FieldUtils.safeMultiply(Long.MIN_VALUE, 100);\n267: fail();\n268: } catch (ArithmeticException e) {\n269: }\n270: 271: try {\n272: FieldUtils.safeMultiply(Long.MIN_VALUE, Integer.MAX_VALUE);\n273: fail();\n274: } catch (ArithmeticException e) {\n275: }\n276: 277: try {\n278: FieldUtils.safeMultiply(Long.MAX_VALUE, Integer.MIN_VALUE);\n279: fail();\n280: } catch (ArithmeticException e) {\n281: }\n282: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(JI)J",
                                    "method_body": "public static long safeMultiply(long val1, int val2) {\nswitch (val2) {\nreturn -val1;\nreturn 0L;\nreturn val1;\nlong total = val1 * val2;\nif (total / val2 != val1) {\nreturn total;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly_baseStartYear",
                            "test_body": "873: public void testParseInto_monthOnly_baseStartYear() {\n874: DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n875: MutableDateTime result = new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO);\n876: assertEquals(1, f.parseInto(result, \"5\", 0));\n877: assertEquals(new MutableDateTime(2004, 5, 1, 12, 20, 30, 0, TOKYO), result);\n878: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly_baseEndYear",
                            "test_body": "887: public void testParseInto_monthOnly_baseEndYear() {\n888: DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n889: MutableDateTime result = new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO);\n890: assertEquals(1, f.parseInto(result, \"5\", 0));\n891: assertEquals(new MutableDateTime(2004, 5, 31, 12, 20, 30, 0, TOKYO), result);\n892: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly_parseStartYear",
                            "test_body": "880: public void testParseInto_monthOnly_parseStartYear() {\n881: DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n882: MutableDateTime result = new MutableDateTime(2004, 2, 1, 12, 20, 30, 0, TOKYO);\n883: assertEquals(1, f.parseInto(result, \"1\", 0));\n884: assertEquals(new MutableDateTime(2004, 1, 1, 12, 20, 30, 0, TOKYO), result);\n885: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_withDefaultYear_feb29",
                            "test_body": "908: public void testParseInto_monthDay_withDefaultYear_feb29() {\n909: DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withDefaultYear(2012);\n910: MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n911: assertEquals(4, f.parseInto(result, \"2 29\", 0));\n912: assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n913: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withDefaultYear(I)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withDefaultYear(int defaultYear) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly",
                            "test_body": "866: public void testParseInto_monthOnly() {\n867: DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n868: MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n869: assertEquals(1, f.parseInto(result, \"5\", 0));\n870: assertEquals(new MutableDateTime(2004, 5, 9, 12, 20, 30, 0, LONDON), result);\n871: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthOnly_parseEndYear",
                            "test_body": "894: public void testParseInto_monthOnly_parseEndYear() {\n895: DateTimeFormatter f = DateTimeFormat.forPattern(\"M\").withLocale(Locale.UK);\n896: MutableDateTime result = new MutableDateTime(2004, 1, 31, 12, 20, 30, 0,TOKYO);\n897: assertEquals(2, f.parseInto(result, \"12\", 0));\n898: assertEquals(new MutableDateTime(2004, 12, 31, 12, 20, 30, 0, TOKYO), result);\n899: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseInto_monthDay_feb29",
                            "test_body": "901: public void testParseInto_monthDay_feb29() {\n902: DateTimeFormatter f = DateTimeFormat.forPattern(\"M d\").withLocale(Locale.UK);\n903: MutableDateTime result = new MutableDateTime(2004, 1, 9, 12, 20, 30, 0, LONDON);\n904: assertEquals(4, f.parseInto(result, \"2 29\", 0));\n905: assertEquals(new MutableDateTime(2004, 2, 29, 12, 20, 30, 0, LONDON), result);\n906: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new UnpaddedNumber(fieldType, maxDigits, false));\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withLocale(Ljava/util/Locale;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withLocale(Locale locale) {\nif (locale == getLocale() || (locale != null && locale.equals(getLocale()))) {\nreturn new DateTimeFormatter(iPrinter, iParser, locale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:getLocale()Ljava/util/Locale;",
                                    "method_body": "public Locale getLocale() {\nreturn iLocale;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseInto(Lorg/joda/time/ReadWritableInstant;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(ReadWritableInstant instant, String text, int position) {\nDateTimeParser parser = requireParser();\nif (instant == null) {\nlong instantMillis = instant.getMillis();\nChronology chrono = instant.getChronology();\nlong instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\nchrono = selectChronology(chrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(\nint newPos = parser.parseInto(bucket, text, position);\ninstant.setMillis(bucket.computeMillis(false, text));\nif (iOffsetParsed && bucket.getOffsetInteger() != null) {\n} else if (bucket.getZone() != null) {\nchrono = chrono.withZone(bucket.getZone());\ninstant.setChronology(chrono);\nif (iZone != null) {\nreturn newPos;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$UnpaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZ)V",
                                    "method_body": "protected UnpaddedNumber(DateTimeFieldType fieldType,\nsuper(fieldType, maxParsedDigits, signed);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\nif (resetFields) {\n}\nif (iOffset != null) {\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 1;\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public MutableDateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug3476684_adjustOffset",
                            "test_body": "1249: public void testBug3476684_adjustOffset() {\n1250: final DateTimeZone zone = DateTimeZone.forID(\"America/Sao_Paulo\");\n1251: DateTime base = new DateTime(2012, 2, 25, 22, 15, zone);\n1252: DateTime baseBefore = base.plusHours(1);  // 23:15 (first)\n1253: DateTime baseAfter = base.plusHours(2);  // 23:15 (second)\n1254: 1255: assertSame(base, base.withEarlierOffsetAtOverlap());\n1256: assertSame(base, base.withLaterOffsetAtOverlap());\n1257: 1258: assertSame(baseBefore, baseBefore.withEarlierOffsetAtOverlap());\n1259: assertEquals(baseAfter, baseBefore.withLaterOffsetAtOverlap());\n1260: 1261: assertSame(baseAfter, baseAfter.withLaterOffsetAtOverlap());\n1262: assertEquals(baseBefore, baseAfter.withEarlierOffsetAtOverlap());\n1263: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal >= 0) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:convertUTCToLocal(J)J",
                                    "method_body": "public long convertUTCToLocal(long instantUTC) {\nint offset = getOffset(instantUTC);\nlong instantLocal = instantUTC + offset;\nif ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\nreturn instantLocal;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:convertLocalToUTC(JZJ)J",
                                    "method_body": "public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\nint offsetOriginal = getOffset(originalInstantUTC);\nlong instantUTC = instantLocal - offsetOriginal;\nint offsetLocalFromOriginal = getOffset(instantUTC);\nif (offsetLocalFromOriginal == offsetOriginal) {\nreturn instantUTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:adjustOffset(JZ)J",
                                    "method_body": "public long adjustOffset(long instant, boolean earlierOrLater) {\nlong instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\nlong instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\nif (instantBefore == instantAfter) {\nlong local = convertUTCToLocal(instant);\nreturn convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
                                    "method_body": "public abstract boolean equals(Object object);\nreturn 57 + getID().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withEarlierOffsetAtOverlap()Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withEarlierOffsetAtOverlap() {\nlong newMillis = getZone().adjustOffset(getMillis(), false);\nreturn withMillis(newMillis);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withLaterOffsetAtOverlap()Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withLaterOffsetAtOverlap() {\nlong newMillis = getZone().adjustOffset(getMillis(), true);\nreturn withMillis(newMillis);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:plusHours(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime plusHours(int hours) {\nif (hours == 0) {\nlong instant = getChronology().hours().add(getMillis(), hours);\nreturn withMillis(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFraction(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFraction(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nreturn append0(new Fraction(fieldType, minDigits, maxDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendFractionOfSecond(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendFractionOfSecond(int minDigits, int maxDigits) {\nreturn appendFraction(DateTimeFieldType.secondOfDay(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:<init>(Lorg/joda/time/DateTimeFieldType;II)V",
                                    "method_body": "protected Fraction(DateTimeFieldType fieldType, int minDigits, int maxDigits) {\nsuper();\niFieldType = fieldType;\nif (maxDigits > 18) {\niMinDigits = minDigits;\niMaxDigits = maxDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.joda.time.chrono.TestGJChronology.testLeapYearRulesConstruction",
                            "test_body": "494: public void testLeapYearRulesConstruction() {\n495: // 1500 not leap in Gregorian, but is leap in Julian\n496: DateMidnight dt = new DateMidnight(1500, 2, 29, GJChronology.getInstanceUTC());\n497: assertEquals(dt.getYear(), 1500);\n498: assertEquals(dt.getMonthOfYear(), 2);\n499: assertEquals(dt.getDayOfMonth(), 29);\n500: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<clinit>()V",
                                    "method_body": "static final Instant DEFAULT_CUTOVER = new Instant(-12219292800000L);\nprivate static final Map<DateTimeZone, ArrayList<GJChronology>> cCache = new HashMap<DateTimeZone, ArrayList<GJChronology>>();\n* {@link org.joda.time.DateTimeConstants#MONDAY Monday},"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:convertByYear(JLorg/joda/time/Chronology;Lorg/joda/time/Chronology;)J",
                                    "method_body": "private static long convertByYear(long instant, Chronology from, Chronology to) {\nreturn to.getDateTimeMillis\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIIIIII)J",
                                    "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nif ((base = getBase()) != null) {\ninstant = iGregorianChronology.getDateTimeMillis\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
                                    "method_body": "protected void assemble(Fields fields) {\nObject[] params = (Object[])getParam();\nJulianChronology julian = (JulianChronology)params[0];\nGregorianChronology gregorian = (GregorianChronology)params[1];\nInstant cutoverInstant = (Instant)params[2];\niCutoverMillis = cutoverInstant.getMillis();\niJulianChronology = julian;\niGregorianChronology = gregorian;\niCutoverInstant = cutoverInstant;\nif (getBase() != null) {\nif (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\niGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\nfields.copyFieldsFrom(gregorian);\nif (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\nfields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\nfields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\nfields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\nfields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\nfields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\nfields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\nfields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\nfields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\nfields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\nfields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\nfields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\nfields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\nlong cutover = gregorian.year().roundCeiling(iCutoverMillis);\nfields.dayOfYear = new CutoverField(\nlong cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\nfields.weekOfWeekyear = new CutoverField(\nfields.year = new ImpreciseCutoverField(\nfields.years = fields.year.getDurationField();\nfields.yearOfEra = new ImpreciseCutoverField(\nfields.yearOfCentury = new ImpreciseCutoverField(\nfields.centuryOfEra = new ImpreciseCutoverField(\nfields.centuries = fields.centuryOfEra.getDurationField();\nfields.monthOfYear = new ImpreciseCutoverField(\nfields.months = fields.monthOfYear.getDurationField();\nfields.weekyear = new ImpreciseCutoverField(\nfields.weekyearOfCentury = new ImpreciseCutoverField(\nfields.weekyears = fields.weekyear.getDurationField();\nCutoverField cf = new CutoverField\ncf.iRangeDurationField = fields.months;\nfields.dayOfMonth = cf;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:julianToGregorianByYear(J)J",
                                    "method_body": "long julianToGregorianByYear(long instant) {\nreturn convertByYear(instant, iJulianChronology, iGregorianChronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateMidnight:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateMidnight(int year, int monthOfYear, int dayOfMonth, Chronology chronology) {\nsuper(year, monthOfYear, dayOfMonth, 0, 0, 0, 0, chronology);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 19,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testDateTimeCreation_london",
                            "test_body": "1263: public void testDateTimeCreation_london() {\n1264: DateTimeZone zone = DateTimeZone.forID(\"Europe/London\");\n1265: DateTime base = new DateTime(2011, 10, 30, 1, 15, zone);\n1266: assertEquals(\"2011-10-30T01:15:00.000+01:00\", base.toString());\n1267: assertEquals(\"2011-10-30T01:15:00.000Z\", base.plusHours(1).toString());\n1268: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal > 0) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
                                    "method_body": "public abstract boolean equals(Object object);\nreturn 57 + getID().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 20,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatterBuilder.test_printParseZoneDawsonCreek",
                            "test_body": "255: public void test_printParseZoneDawsonCreek() {  // clashes with shorter Dawson\n256: DateTimeFormatterBuilder bld = new DateTimeFormatterBuilder()\n257: .appendPattern(\"yyyy-MM-dd HH:mm \").appendTimeZoneId();\n258: DateTimeFormatter f = bld.toFormatter();\n259: 260: DateTime dt = new DateTime(2007, 3, 4, 12, 30, 0, DateTimeZone.forID(\"America/Dawson_Creek\"));\n261: assertEquals(\"2007-03-04 12:30 America/Dawson_Creek\", f.print(dt));\n262: assertEquals(dt, f.parseDateTime(\"2007-03-04 12:30 America/Dawson_Creek\"));\n263: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\n} else if (offsetLocal > 0) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
                                    "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn instant.getMillis();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneId()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneId() {\nreturn append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendPattern(String pattern) {\nDateTimeFormat.appendPatternTo(this, pattern);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
                                    "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
                                    "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
                                    "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
                                    "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nreturn printer;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseDateTime(Ljava/lang/String;)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime parseDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null);\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nthrow new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:createErrorMessage(Ljava/lang/String;I)Ljava/lang/String;",
                                    "method_body": "static String createErrorMessage(final String text, final int errorPos) {\nint sampleLen = errorPos + 32;\nif (text.length() <= sampleLen + 3) {\nsampleText = text;\nif (errorPos <= 0) {\nif (errorPos >= text.length()) {\nreturn \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:appendPatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\nparsePatternTo(builder, pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen == 2) {\nint maxDigits = 9;\nif (i + 1 < length) {\nindexRef[0]++;\nif (isNumericToken(parseToken(pattern, indexRef))) {\nindexRef[0]--;\nswitch (c) {\nbuilder.appendYear(tokenLen, maxDigits);\nbreak;\nbreak;\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendDayOfMonth(tokenLen);\nbreak;\nbuilder.appendHourOfDay(tokenLen);\nbreak;\nbuilder.appendMinuteOfHour(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:<clinit>()V",
                                    "method_body": "static final Set<String> ALL_IDS = DateTimeZone.getAvailableIDs();\nint max = 0;\nfor (String id : ALL_IDS) {\nmax = Math.max(max, id.length());\n}\nMAX_LENGTH = max;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:estimatePrintedLength()I",
                                    "method_body": "public int estimatePrintedLength() {\nreturn MAX_LENGTH;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
                                    "method_body": "public void printTo(\nbuf.append(displayZone != null ? displayZone.getID() : \"\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:estimateParsedLength()I",
                                    "method_body": "public int estimateParsedLength() {\nreturn MAX_LENGTH;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
                                    "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nString str = text.substring(position);\nfor (String id : ALL_IDS) {\nif (str.startsWith(id)) {\nbucket.setZone(DateTimeZone.forID(id));\nreturn position + id.length();\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 22,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestPeriod_Constructors.testConstructor_long_fixedZone",
                            "test_body": "174: public void testConstructor_long_fixedZone() throws Throwable {\n175: DateTimeZone zone = DateTimeZone.getDefault();\n176: try {\n177: DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n178: long length =\n179: (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n180: 5L * DateTimeConstants.MILLIS_PER_HOUR +\n181: 6L * DateTimeConstants.MILLIS_PER_MINUTE +\n182: 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n183: Period test = new Period(length);\n184: assertEquals(PeriodType.standard(), test.getPeriodType());\n185: // only time fields are precise in AllType\n186: assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n187: assertEquals(0, test.getMonths());\n188: assertEquals(0, test.getWeeks());\n189: assertEquals(0, test.getDays());\n190: assertEquals((450 * 24) + 5, test.getHours());\n191: assertEquals(6, test.getMinutes());\n192: assertEquals(7, test.getSeconds());\n193: assertEquals(8, test.getMillis());\n194: } finally {\n195: DateTimeZone.setDefault(zone);\n196: }\n197: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHours(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\nreturn forOffsetHoursMinutes(hoursOffset, 0);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nif (minutesOffset < 0 || minutesOffset > 59) {\nint offset = 0;\nint hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n}\nreturn forOffsetMillis(offset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
                                    "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
                                    "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nreturn (int) total;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(J)V",
                                    "method_body": "public Period(long duration) {\nsuper(duration);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<clinit>()V",
                                    "method_body": "public static final Period ZERO = new Period();\n* Parses a {@code Period} from the specified string."
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getYears()I",
                                    "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getWeeks()I",
                                    "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
                                    "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:minutes()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType minutes() {\nreturn MINUTES_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:hours()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType hours() {\nreturn HOURS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:weeks()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType weeks() {\nreturn WEEKS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:years()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType years() {\nreturn YEARS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:<init>(Ljava/lang/String;[Lorg/joda/time/DurationFieldType;[I)V",
                                    "method_body": "protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\nsuper();\niName = name;\niTypes = types;\niIndices = indices;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
                                    "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\ncStandard = type;\nreturn type;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDuration_Basics.testToPeriod_fixedZone",
                            "test_body": "470: public void testToPeriod_fixedZone() throws Throwable {\n471: DateTimeZone zone = DateTimeZone.getDefault();\n472: try {\n473: DateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\n474: long length =\n475: (4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n476: 5L * DateTimeConstants.MILLIS_PER_HOUR +\n477: 6L * DateTimeConstants.MILLIS_PER_MINUTE +\n478: 7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\n479: Duration dur = new Duration(length);\n480: Period test = dur.toPeriod();\n481: assertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\n482: assertEquals(0, test.getMonths());\n483: assertEquals(0, test.getWeeks());\n484: assertEquals(0, test.getDays());\n485: assertEquals((450 * 24) + 5, test.getHours());\n486: assertEquals(6, test.getMinutes());\n487: assertEquals(7, test.getSeconds());\n488: assertEquals(8, test.getMillis());\n489: } finally {\n490: DateTimeZone.setDefault(zone);\n491: }\n492: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHours(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\nreturn forOffsetHoursMinutes(hoursOffset, 0);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nif (minutesOffset < 0 || minutesOffset > 59) {\nint offset = 0;\nint hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n}\nreturn forOffsetMillis(offset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"WET\", \"WET\");\nmap.put(\"CET\", \"CET\");\nmap.put(\"MET\", \"CET\");\nmap.put(\"ECT\", \"CET\");\nmap.put(\"EET\", \"EET\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indiana/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Kolkata\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Ho_Chi_Minh\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
                                    "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
                                    "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nreturn (int) total;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Duration:<init>(J)V",
                                    "method_body": "public Duration(long duration) {\nsuper(duration);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>()V",
                                    "method_body": "public Period() {\nsuper(0L, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<init>(J)V",
                                    "method_body": "public Period(long duration) {\nsuper(duration);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:<clinit>()V",
                                    "method_body": "public static final Period ZERO = new Period();\n* Parses a {@code Period} from the specified string."
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getYears()I",
                                    "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getMonths()I",
                                    "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Period:getWeeks()I",
                                    "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
                                    "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 23,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZone.testForID_String_old",
                            "test_body": "243: public void testForID_String_old() {\n244: Map<String, String> map = new LinkedHashMap<String, String>();\n245: map.put(\"GMT\", \"UTC\");\n246: map.put(\"WET\", \"WET\");\n247: map.put(\"CET\", \"CET\");\n248: map.put(\"MET\", \"CET\");\n249: map.put(\"ECT\", \"CET\");\n250: map.put(\"EET\", \"EET\");\n251: map.put(\"MIT\", \"Pacific/Apia\");\n252: map.put(\"HST\", \"Pacific/Honolulu\");\n253: map.put(\"AST\", \"America/Anchorage\");\n254: map.put(\"PST\", \"America/Los_Angeles\");\n255: map.put(\"MST\", \"America/Denver\");\n256: map.put(\"PNT\", \"America/Phoenix\");\n257: map.put(\"CST\", \"America/Chicago\");\n258: map.put(\"EST\", \"America/New_York\");\n259: map.put(\"IET\", \"America/Indiana/Indianapolis\");\n260: map.put(\"PRT\", \"America/Puerto_Rico\");\n261: map.put(\"CNT\", \"America/St_Johns\");\n262: map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n263: map.put(\"BET\", \"America/Sao_Paulo\");\n264: map.put(\"ART\", \"Africa/Cairo\");\n265: map.put(\"CAT\", \"Africa/Harare\");\n266: map.put(\"EAT\", \"Africa/Addis_Ababa\");\n267: map.put(\"NET\", \"Asia/Yerevan\");\n268: map.put(\"PLT\", \"Asia/Karachi\");\n269: map.put(\"IST\", \"Asia/Kolkata\");\n270: map.put(\"BST\", \"Asia/Dhaka\");\n271: map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n272: map.put(\"CTT\", \"Asia/Shanghai\");\n273: map.put(\"JST\", \"Asia/Tokyo\");\n274: map.put(\"ACT\", \"Australia/Darwin\");\n275: map.put(\"AET\", \"Australia/Sydney\");\n276: map.put(\"SST\", \"Pacific/Guadalcanal\");\n277: map.put(\"NST\", \"Pacific/Auckland\");\n278: for (String key : map.keySet()) {\n279: String value = map.get(key);\n280: TimeZone juZone = TimeZone.getTimeZone(key);\n281: DateTimeZone zone = DateTimeZone.forTimeZone(juZone);\n282: assertEquals(value, zone.getID());\n283: //            System.out.println(juZone);\n284: //            System.out.println(juZone.getDisplayName());\n285: //            System.out.println(zone);\n286: //            System.out.println(\"------\");\n287: }\n288: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\ndtz = cProvider.getZone(convId);\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 24,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2010",
                            "test_body": "425: public void testParseLocalDate_weekyear_month_week_2010() {\n426: Chronology chrono = GJChronology.getInstanceUTC();\n427: DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n428: assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n429: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekyear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen == 2) {\nint maxDigits = 9;\nif (i + 1 < length) {\nindexRef[0]++;\nif (isNumericToken(parseToken(pattern, indexRef))) {\nindexRef[0]--;\nswitch (c) {\nbuilder.appendWeekyear(tokenLen, maxDigits);\nbreak;\nbuilder.appendYear(tokenLen, maxDigits);\nbreak;\nbreak;\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendWeekOfWeekyear(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012",
                            "test_body": "437: public void testParseLocalDate_weekyear_month_week_2012() {\n438: Chronology chrono = GJChronology.getInstanceUTC();\n439: DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n440: assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n441: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekyear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen == 2) {\nint maxDigits = 9;\nif (i + 1 < length) {\nindexRef[0]++;\nif (isNumericToken(parseToken(pattern, indexRef))) {\nindexRef[0]--;\nswitch (c) {\nbuilder.appendWeekyear(tokenLen, maxDigits);\nbreak;\nbuilder.appendYear(tokenLen, maxDigits);\nbreak;\nbreak;\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendWeekOfWeekyear(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2011",
                            "test_body": "431: public void testParseLocalDate_weekyear_month_week_2011() {\n432: Chronology chrono = GJChronology.getInstanceUTC();\n433: DateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\n434: assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n435: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekyear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekyear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.weekyear(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parsePatternTo(Lorg/joda/time/format/DateTimeFormatterBuilder;Ljava/lang/String;)V",
                                    "method_body": "private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\nint length = pattern.length();\nint[] indexRef = new int[1];\nfor (int i=0; i<length; i++) {\nindexRef[0] = i;\nString token = parseToken(pattern, indexRef);\ni = indexRef[0];\nint tokenLen = token.length();\nif (tokenLen == 0) {\nchar c = token.charAt(0);\nswitch (c) {\nif (tokenLen == 2) {\nint maxDigits = 9;\nif (i + 1 < length) {\nindexRef[0]++;\nif (isNumericToken(parseToken(pattern, indexRef))) {\nindexRef[0]--;\nswitch (c) {\nbuilder.appendWeekyear(tokenLen, maxDigits);\nbreak;\nbuilder.appendYear(tokenLen, maxDigits);\nbreak;\nbreak;\nif (tokenLen >= 3) {\nbuilder.appendMonthOfYear(tokenLen);\nbreak;\nbuilder.appendWeekOfWeekyear(tokenLen);\nbreak;\nString sub = token.substring(1);\nif (sub.length() == 1) {\nbuilder.appendLiteral(sub.charAt(0));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2011",
                            "test_body": "457: public void testParseLocalDate_year_month_week_2011() {\n458: Chronology chrono = GJChronology.getInstanceUTC();\n459: DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n460: assertEquals(new LocalDate(2011, 1, 3, chrono), f.parseLocalDate(\"2011-01-01\"));\n461: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2010",
                            "test_body": "451: public void testParseLocalDate_year_month_week_2010() {\n452: Chronology chrono = GJChronology.getInstanceUTC();\n453: DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n454: assertEquals(new LocalDate(2010, 1, 4, chrono), f.parseLocalDate(\"2010-01-01\"));\n455: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2016",
                            "test_body": "487: public void testParseLocalDate_year_month_week_2016() {\n488: Chronology chrono = GJChronology.getInstanceUTC();\n489: DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n490: assertEquals(new LocalDate(2016, 1, 4, chrono), f.parseLocalDate(\"2016-01-01\"));\n491: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_year_month_week_2012",
                            "test_body": "463: public void testParseLocalDate_year_month_week_2012() {\n464: Chronology chrono = GJChronology.getInstanceUTC();\n465: DateTimeFormatter f = DateTimeFormat.forPattern(\"yyyy-MM-ww\").withChronology(chrono);\n466: assertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n467: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n} catch (RuntimeException ex) {\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\nif (temp == null) {\ncDefault = zone = temp;\n}\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forTimeZone(Ljava/util/TimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forTimeZone(TimeZone zone) {\nif (zone == null) {\nfinal String id = zone.getID();\nif (id.equals(\"UTC\")) {\nDateTimeZone dtz = null;\nString convId = getConvertedId(id);\nif (convId != null) {\nif (dtz == null) {\ndtz = cProvider.getZone(id);\nif (dtz != null) {\nreturn dtz;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getConvertedId(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private static synchronized String getConvertedId(String id) {\nMap<String, String> map = cZoneIdConversion;\nif (map == null) {\nmap = new HashMap<String, String>();\nmap.put(\"GMT\", \"UTC\");\nmap.put(\"MIT\", \"Pacific/Apia\");\nmap.put(\"HST\", \"Pacific/Honolulu\");\nmap.put(\"AST\", \"America/Anchorage\");\nmap.put(\"PST\", \"America/Los_Angeles\");\nmap.put(\"MST\", \"America/Denver\");\nmap.put(\"PNT\", \"America/Phoenix\");\nmap.put(\"CST\", \"America/Chicago\");\nmap.put(\"EST\", \"America/New_York\");\nmap.put(\"IET\", \"America/Indianapolis\");\nmap.put(\"PRT\", \"America/Puerto_Rico\");\nmap.put(\"CNT\", \"America/St_Johns\");\nmap.put(\"AGT\", \"America/Buenos_Aires\");\nmap.put(\"BET\", \"America/Sao_Paulo\");\nmap.put(\"WET\", \"Europe/London\");\nmap.put(\"ECT\", \"Europe/Paris\");\nmap.put(\"ART\", \"Africa/Cairo\");\nmap.put(\"CAT\", \"Africa/Harare\");\nmap.put(\"EET\", \"Europe/Bucharest\");\nmap.put(\"EAT\", \"Africa/Addis_Ababa\");\nmap.put(\"MET\", \"Asia/Tehran\");\nmap.put(\"NET\", \"Asia/Yerevan\");\nmap.put(\"PLT\", \"Asia/Karachi\");\nmap.put(\"IST\", \"Asia/Calcutta\");\nmap.put(\"BST\", \"Asia/Dhaka\");\nmap.put(\"VST\", \"Asia/Saigon\");\nmap.put(\"CTT\", \"Asia/Shanghai\");\nmap.put(\"JST\", \"Asia/Tokyo\");\nmap.put(\"ACT\", \"Australia/Darwin\");\nmap.put(\"AET\", \"Australia/Sydney\");\nmap.put(\"SST\", \"Pacific/Guadalcanal\");\nmap.put(\"NST\", \"Pacific/Auckland\");\ncZoneIdConversion = map;\nreturn map.get(id);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
                                    "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:secondOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType secondOfDay() {\nreturn SECOND_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfDay() {\nreturn CLOCKHOUR_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:hourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType hourOfHalfday() {\nreturn HOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:clockhourOfHalfday()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType clockhourOfHalfday() {\nreturn CLOCKHOUR_OF_HALFDAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:halfdayOfDay()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType halfdayOfDay() {\nreturn HALFDAY_OF_DAY_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:dayOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType dayOfYear() {\nreturn DAY_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekOfWeekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekOfWeekyear() {\nreturn WEEK_OF_WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:weekyear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType weekyear() {\nreturn WEEKYEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:yearOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType yearOfEra() {\nreturn YEAR_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:centuryOfEra()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType centuryOfEra() {\nreturn CENTURY_OF_ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:era()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType era() {\nreturn ERA_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSignedDecimal(Lorg/joda/time/DateTimeFieldType;II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSignedDecimal(\nif (fieldType == null) {\nif (maxDigits < minDigits) {\nif (minDigits < 0 || maxDigits <= 0) {\nif (minDigits <= 1) {\nreturn append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nreturn append0(new TextField(fieldType, true));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendSecondOfMinute(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendSecondOfMinute(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.secondOfMinute(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMinuteOfHour(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendHourOfDay(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfMonth(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendWeekOfWeekyear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendWeekOfWeekyear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.weekOfWeekyear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendMonthOfYear(I)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\nreturn appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendYear(II)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\nreturn appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:<init>(Lorg/joda/time/DateTimeFieldType;IZI)V",
                                    "method_body": "protected PaddedNumber(DateTimeFieldType fieldType, int maxParsedDigits,\nsuper(fieldType, maxParsedDigits, signed);\niMinPrintedDigits = minPrintedDigits;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
                                    "method_body": "private DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
                                    "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\nreturn new LocalDateTime(millis, chrono);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
                                    "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nreturn parser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
                                    "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
                                    "method_body": "private final Chronology iChrono;\nprivate SavedField[] iSavedFields = new SavedField[8];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
                                    "method_body": "public int getOffset() {\nreturn iOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
                                    "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
                                    "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
                                    "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\nsort(savedFields, count);\nif (count > 0) {\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nlong millis = iMillis;\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (iZone == null) {\nmillis -= iOffset;\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
                                    "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
                                    "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn -1;\nif (b == null || !b.isSupported()) {\nreturn -a.compareTo(b);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
                                    "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
                                    "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\nif (reset) {\nmillis = iField.roundFloor(millis);\nreturn millis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
                                    "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\nif (result != 0) {\nreturn result;\nreturn compareReverse\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:<init>(J)V",
                                    "method_body": "public Instant(long instant) {\nsuper();\niMillis = instant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.Instant:getMillis()J",
                                    "method_body": "public long getMillis() {\nreturn iMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(JulianChronology julian,\nsuper(null, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/chrono/JulianChronology;Lorg/joda/time/chrono/GregorianChronology;Lorg/joda/time/Instant;)V",
                                    "method_body": "private GJChronology(Chronology base,\nsuper(base, new Object[] {julian, gregorian, cutoverInstant});\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static GJChronology getInstance(\nreturn getInstance(zone, gregorianCutover, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
                                    "method_body": "public static synchronized GJChronology getInstance(\nzone = DateTimeUtils.getZone(zone);\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\ncutoverInstant = gregorianCutover.toInstant();\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\nreturn chrono;\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\nchronos.add(chrono);\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
                                    "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
                                    "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.JulianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/JulianChronology;",
                                    "method_body": "public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nJulianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new JulianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new JulianChronology(null, null, minDaysInFirstWeek);\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:parseToken(Ljava/lang/String;[I)Ljava/lang/String;",
                                    "method_body": "private static String parseToken(String pattern, int[] indexRef) {\nStringBuffer buf = new StringBuffer();\nint i = indexRef[0];\nint length = pattern.length();\nchar c = pattern.charAt(i);\nif (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\nbuf.append(c);\nwhile (i + 1 < length) {\nchar peek = pattern.charAt(i + 1);\nif (peek == c) {\nbuf.append(c);\ni++;\n}\nbuf.append('\\'');\nboolean inLiteral = false;\nfor (; i < length; i++) {\nc = pattern.charAt(i);\nif (c == '\\'') {\n} else if (!inLiteral &&\ni--;\nbreak;\nbuf.append(c);\nindexRef[0] = i;\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:isNumericToken(Ljava/lang/String;)Z",
                                    "method_body": "private static boolean isNumericToken(String token) {\nint tokenLen = token.length();\nif (tokenLen > 0) {\nchar c = token.charAt(0);\nswitch (c) {\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormat:createFormatterForPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "private static DateTimeFormatter createFormatterForPattern(String pattern) {\nif (pattern == null || pattern.length() == 0) {\nDateTimeFormatter formatter = null;\nsynchronized (cPatternedCache) {\nformatter = cPatternedCache.get(pattern);\nif (formatter == null) {\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nparsePatternTo(builder, pattern);\nformatter = builder.toFormatter();\ncPatternedCache.put(pattern, formatter);\n}\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
                                    "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
                                    "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
                                    "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
                                    "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
                                    "method_body": "public LocalDate(\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 25,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn",
                            "test_body": "889: public void test_getOffsetFromLocal_Moscow_Autumn() {\n890: doTest_getOffsetFromLocal(10, 28, 0, 0, \"2007-10-28T00:00:00.000+04:00\", ZONE_MOSCOW);\n891: doTest_getOffsetFromLocal(10, 28, 0,30, \"2007-10-28T00:30:00.000+04:00\", ZONE_MOSCOW);\n892: doTest_getOffsetFromLocal(10, 28, 1, 0, \"2007-10-28T01:00:00.000+04:00\", ZONE_MOSCOW);\n893: doTest_getOffsetFromLocal(10, 28, 1,30, \"2007-10-28T01:30:00.000+04:00\", ZONE_MOSCOW);\n894: 895: doTest_getOffsetFromLocal(10, 28, 2, 0, \"2007-10-28T02:00:00.000+04:00\", ZONE_MOSCOW);\n896: doTest_getOffsetFromLocal(10, 28, 2,30, \"2007-10-28T02:30:00.000+04:00\", ZONE_MOSCOW);\n897: doTest_getOffsetFromLocal(10, 28, 2,30,59,999, \"2007-10-28T02:30:59.999+04:00\", ZONE_MOSCOW);\n898: doTest_getOffsetFromLocal(10, 28, 2,59,59,998, \"2007-10-28T02:59:59.998+04:00\", ZONE_MOSCOW);\n899: doTest_getOffsetFromLocal(10, 28, 2,59,59,999, \"2007-10-28T02:59:59.999+04:00\", ZONE_MOSCOW);\n900: 901: doTest_getOffsetFromLocal(10, 28, 3, 0, \"2007-10-28T03:00:00.000+03:00\", ZONE_MOSCOW);\n902: doTest_getOffsetFromLocal(10, 28, 3,30, \"2007-10-28T03:30:00.000+03:00\", ZONE_MOSCOW);\n903: doTest_getOffsetFromLocal(10, 28, 4, 0, \"2007-10-28T04:00:00.000+03:00\", ZONE_MOSCOW);\n904: doTest_getOffsetFromLocal(10, 28, 5, 0, \"2007-10-28T05:00:00.000+03:00\", ZONE_MOSCOW);\n905: doTest_getOffsetFromLocal(10, 28, 6, 0, \"2007-10-28T06:00:00.000+03:00\", ZONE_MOSCOW);\n906: doTest_getOffsetFromLocal(10, 28, 7, 0, \"2007-10-28T07:00:00.000+03:00\", ZONE_MOSCOW);\n907: doTest_getOffsetFromLocal(10, 28, 8, 0, \"2007-10-28T08:00:00.000+03:00\", ZONE_MOSCOW);\n908: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\nif ((offsetLocal - offsetAdjusted) < 0) {\nlong nextLocal = nextTransition(instantAdjusted);\nlong nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\nif (nextLocal != nextAdjusted) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
                                    "method_body": "public abstract boolean equals(Object object);\nreturn 57 + getID().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(long instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.test_getOffsetFromLocal_Moscow_Autumn_overlap_mins",
                            "test_body": "910: public void test_getOffsetFromLocal_Moscow_Autumn_overlap_mins() {\n911: for (int min = 0; min < 60; min++) {\n912: if (min < 10) {\n913: doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:0\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n914: } else {\n915: doTest_getOffsetFromLocal(10, 28, 2, min, \"2007-10-28T02:\" + min + \":00.000+04:00\", ZONE_MOSCOW);\n916: }\n917: }\n918: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\nif ((offsetLocal - offsetAdjusted) < 0) {\nlong nextLocal = nextTransition(instantAdjusted);\nlong nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\nif (nextLocal != nextAdjusted) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
                                    "method_body": "public abstract boolean equals(Object object);\nreturn 57 + getID().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(long instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.test_DateTime_constructor_Moscow_Autumn",
                            "test_body": "920: public void test_DateTime_constructor_Moscow_Autumn() {\n921: DateTime dt = new DateTime(2007, 10, 28, 2, 30, ZONE_MOSCOW);\n922: assertEquals(\"2007-10-28T02:30:00.000+04:00\", dt.toString());\n923: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
                                    "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\niID = id;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:<clinit>()V",
                                    "method_body": "private static final long serialVersionUID = 5546345482340108586L;\npublic static final DateTimeZone UTC = new FixedDateTimeZone(\"UTC\", \"UTC\", 0, 0);\nsetProvider0(null);\nsetNameProvider0(null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setProvider0(Lorg/joda/time/tz/Provider;)V",
                                    "method_body": "private static void setProvider0(Provider provider) {\nif (provider == null) {\nprovider = getDefaultProvider();\nSet<String> ids = provider.getAvailableIDs();\nif (ids == null || ids.size() == 0) {\nif (!ids.contains(\"UTC\")) {\nif (!UTC.equals(provider.getZone(\"UTC\"))) {\ncProvider = provider;\ncAvailableIDs = ids;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultProvider()Lorg/joda/time/tz/Provider;",
                                    "method_body": "private static Provider getDefaultProvider() {\nProvider provider = null;\nString providerClass =\nif (providerClass != null) {\n}\nif (provider == null) {\nprovider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n}\nif (provider == null) {\nreturn provider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:setNameProvider0(Lorg/joda/time/tz/NameProvider;)V",
                                    "method_body": "private static void setNameProvider0(NameProvider nameProvider) {\nif (nameProvider == null) {\nnameProvider = getDefaultNameProvider();\ncNameProvider = nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getDefaultNameProvider()Lorg/joda/time/tz/NameProvider;",
                                    "method_body": "private static NameProvider getDefaultNameProvider() {\nNameProvider nameProvider = null;\nString providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\nif (providerClass != null) {\n}\nif (nameProvider == null) {\nnameProvider = new DefaultNameProvider();\nreturn nameProvider;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
                                    "method_body": "public final String getID() {\nreturn iID;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
                                    "method_body": "public int getOffsetFromLocal(long instantLocal) {\nfinal int offsetLocal = getOffset(instantLocal);\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\nif (offsetLocal != offsetAdjusted) {\nif ((offsetLocal - offsetAdjusted) < 0) {\nlong nextLocal = nextTransition(instantAdjusted);\nlong nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\nif (nextLocal != nextAdjusted) {\nreturn offsetAdjusted;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
                                    "method_body": "public abstract boolean equals(Object object);\nreturn 57 + getID().hashCode();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 26,
                    "tests": [
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithHourOfDayInDstChange",
                            "test_body": "1083: public void testWithHourOfDayInDstChange() {\n1084: DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n1085: assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n1086: DateTime test = dateTime.withHourOfDay(2);\n1087: assertEquals(\"2010-10-31T02:30:10.123+02:00\", test.toString());\n1088: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(Object instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withHourOfDay(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withHourOfDay(int hour) {\nreturn withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithSecondOfMinuteInDstChange",
                            "test_body": "1097: public void testWithSecondOfMinuteInDstChange() {\n1098: DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n1099: assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n1100: DateTime test = dateTime.withSecondOfMinute(0);\n1101: assertEquals(\"2010-10-31T02:30:00.123+02:00\", test.toString());\n1102: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(Object instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withSecondOfMinute(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withSecondOfMinute(int second) {\nreturn withMillis(getChronology().secondOfMinute().set(getMillis(), second));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_Paris_summer",
                            "test_body": "1104: public void testWithMillisOfSecondInDstChange_Paris_summer() {\n1105: DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n1106: assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n1107: DateTime test = dateTime.withMillisOfSecond(0);\n1108: assertEquals(\"2010-10-31T02:30:10.000+02:00\", test.toString());\n1109: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(Object instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillisOfSecond(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillisOfSecond(int millis) {\nreturn withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_usCentral",
                            "test_body": "1153: public void testBug2182444_usCentral() {\n1154: Chronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\n1155: Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n1156: DateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\n1157: DateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\n1158: assertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\n1159: assertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\n1160: 1161: DateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\n1162: DateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\n1163: assertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\n1164: assertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\n1165: assertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\n1166: assertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\n1167: assertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\n1168: assertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\n1169: assertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n1170: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:isStandardOffset(J)Z",
                                    "method_body": "public boolean isStandardOffset(long instant) {\nreturn getOffset(instant) == getStandardOffset(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:toDateTime(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime toDateTime(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nif (getChronology() == chronology) {\nreturn super.toDateTime(chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withHourOfDay(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withHourOfDay(int hour) {\nreturn withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ISOChronology:<init>(Lorg/joda/time/Chronology;)V",
                                    "method_body": "private ISOChronology(Chronology base) {\nsuper(base, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\nchrono = new GregorianChronology\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_ausNSW",
                            "test_body": "1172: public void testBug2182444_ausNSW() {\n1173: Chronology chronAusNSW = GregorianChronology.getInstance(DateTimeZone.forID(\"Australia/NSW\"));\n1174: Chronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\n1175: DateTime australiaNSWStandardInUTC = new DateTime(2008, 4, 5, 16, 0, 0, 0, chronUTC);\n1176: DateTime australiaNSWDaylightInUTC = new DateTime(2008, 4, 5, 15, 0, 0, 0, chronUTC);\n1177: assertTrue(\"Should be standard time\", chronAusNSW.getZone().isStandardOffset(australiaNSWStandardInUTC.getMillis()));\n1178: assertFalse(\"Should be daylight time\", chronAusNSW.getZone().isStandardOffset(australiaNSWDaylightInUTC.getMillis()));\n1179: 1180: DateTime australiaNSWStandardInAustraliaNSW = australiaNSWStandardInUTC.toDateTime(chronAusNSW);\n1181: DateTime australiaNSWDaylightInAusraliaNSW = australiaNSWDaylightInUTC.toDateTime(chronAusNSW);\n1182: assertEquals(2, australiaNSWStandardInAustraliaNSW.getHourOfDay());\n1183: assertEquals(australiaNSWStandardInAustraliaNSW.getHourOfDay(), australiaNSWDaylightInAusraliaNSW.getHourOfDay());\n1184: assertTrue(australiaNSWStandardInAustraliaNSW.getMillis() != australiaNSWDaylightInAusraliaNSW.getMillis());\n1185: assertEquals(australiaNSWStandardInAustraliaNSW, australiaNSWStandardInAustraliaNSW.withHourOfDay(2));\n1186: assertEquals(australiaNSWStandardInAustraliaNSW.getMillis() + 3, australiaNSWStandardInAustraliaNSW.withMillisOfSecond(3).getMillis());\n1187: assertEquals(australiaNSWDaylightInAusraliaNSW, australiaNSWDaylightInAusraliaNSW.withHourOfDay(2));\n1188: assertEquals(australiaNSWDaylightInAusraliaNSW.getMillis() + 3, australiaNSWDaylightInAusraliaNSW.withMillisOfSecond(3).getMillis());\n1189: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nif (id.equals(\"UTC\")) {\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:isStandardOffset(J)Z",
                                    "method_body": "public boolean isStandardOffset(long instant) {\nreturn getOffset(instant) == getStandardOffset(instant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:toDateTime(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime toDateTime(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nif (getChronology() == chronology) {\nreturn super.toDateTime(chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withHourOfDay(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withHourOfDay(int hour) {\nreturn withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
                                    "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
                                    "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
                                    "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
                                    "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\nchrono = chronos[minDaysInFirstWeek - 1];\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\nchrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\nchrono = new GregorianChronology\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
                                    "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nbase = base.withUTC();\nif (base == null) {\nif (zone == null) {\nreturn new ZonedChronology(base, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
                                    "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
                                    "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "private DateTimeFormatterBuilder append0(\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendTimeZoneOffset(Ljava/lang/String;ZII)Lorg/joda/time/format/DateTimeFormatterBuilder;",
                                    "method_body": "public DateTimeFormatterBuilder appendTimeZoneOffset(\nreturn append0(new TimeZoneOffset\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
                                    "method_body": "private Object getFormatter() {\nObject f = iFormatter;\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\nif (f == null) {\nf = new Composite(iElementPairs);\niFormatter = f;\nreturn f;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
                                    "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
                                    "method_body": "public DateTimeFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
                                    "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nif (iZone != null) {\nreturn chrono;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nsuper();\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\niPrintedLengthEstimate = printEst;\nif (parserList.size() <= 0) {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\niParsedLengthEstimate = parseEst;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
                                    "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
                                    "method_body": "boolean isParser() {\nreturn iParsers != null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:<init>(Ljava/lang/String;Ljava/lang/String;ZII)V",
                                    "method_body": "TimeZoneOffset(String zeroOffsetPrintText, String zeroOffsetParseText,\nsuper();\niZeroOffsetPrintText = zeroOffsetPrintText;\niZeroOffsetParseText = zeroOffsetParseText;\niShowSeparators = showSeparators;\nif (minFields <= 0 || maxFields < minFields) {\nif (minFields > 4) {\niMinFields = minFields;\niMaxFields = maxFields;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillisOfSecond(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillisOfSecond(int millis) {\nreturn withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithMinuteOfHourInDstChange_mockZone",
                            "test_body": "1063: public void testWithMinuteOfHourInDstChange_mockZone() {\n1064: DateTime cutover = new DateTime(2010, 10, 31, 1, 15, DateTimeZone.forOffsetHoursMinutes(0, 30));\n1065: assertEquals(\"2010-10-31T01:15:00.000+00:30\", cutover.toString());\n1066: DateTimeZone halfHourZone = new MockZone(cutover.getMillis(), 3600000, -1800);\n1067: DateTime pre = new DateTime(2010, 10, 31, 1, 0, halfHourZone);\n1068: assertEquals(\"2010-10-31T01:00:00.000+01:00\", pre.toString());\n1069: DateTime post = new DateTime(2010, 10, 31, 1, 59, halfHourZone);\n1070: assertEquals(\"2010-10-31T01:59:00.000+00:30\", post.toString());\n1071: 1072: DateTime testPre1 = pre.withMinuteOfHour(30);\n1073: assertEquals(\"2010-10-31T01:30:00.000+01:00\", testPre1.toString());  // retain offset\n1074: DateTime testPre2 = pre.withMinuteOfHour(50);\n1075: assertEquals(\"2010-10-31T01:50:00.000+00:30\", testPre2.toString());\n1076: 1077: DateTime testPost1 = post.withMinuteOfHour(30);\n1078: assertEquals(\"2010-10-31T01:30:00.000+00:30\", testPost1.toString());  // retain offset\n1079: DateTime testPost2 = post.withMinuteOfHour(10);\n1080: assertEquals(\"2010-10-31T01:10:00.000+01:00\", testPost2.toString());\n1081: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMinuteOfHour(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMinuteOfHour(int minute) {\nreturn withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nif (minutesOffset < 0 || minutesOffset > 59) {\nint offset = 0;\nint hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n}\nreturn forOffsetMillis(offset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
                                    "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
                                    "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public FixedDateTimeZone(String id, String nameKey,\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(IIIIILorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(\nsuper(year, monthOfYear, dayOfMonth,\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
                                    "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nreturn sum;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
                                    "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nreturn (int) total;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
                                    "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nif (value < 1000) {\n} else if (value < 10000) {\ndigits = 4;\nfor (; size > digits; size--) {\nbuf.append(Integer.toString(value));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithMillisOfSecondInDstChange_NewYork_winter",
                            "test_body": "1125: public void testWithMillisOfSecondInDstChange_NewYork_winter() {\n1126: DateTime dateTime = new DateTime(\"2007-11-04T01:30:00.123-05:00\", ZONE_NEW_YORK);\n1127: assertEquals(\"2007-11-04T01:30:00.123-05:00\", dateTime.toString());\n1128: DateTime test = dateTime.withMillisOfSecond(0);\n1129: assertEquals(\"2007-11-04T01:30:00.000-05:00\", test.toString());\n1130: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(Object instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillisOfSecond(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillisOfSecond(int millis) {\nreturn withMillis(getChronology().millisOfSecond().set(getMillis(), millis));\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.joda.time.TestDateTimeZoneCutover.testWithMinuteOfHourInDstChange",
                            "test_body": "1090: public void testWithMinuteOfHourInDstChange() {\n1091: DateTime dateTime = new DateTime(\"2010-10-31T02:30:10.123+02:00\", ZONE_PARIS);\n1092: assertEquals(\"2010-10-31T02:30:10.123+02:00\", dateTime.toString());\n1093: DateTime test = dateTime.withMinuteOfHour(0);\n1094: assertEquals(\"2010-10-31T02:00:10.123+02:00\", test.toString());\n1095: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
                                    "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:<init>(Ljava/lang/Object;Lorg/joda/time/DateTimeZone;)V",
                                    "method_body": "public DateTime(Object instant, DateTimeZone zone) {\nsuper(instant, zone);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
                                    "method_body": "ZonedDateTimeField(DateTimeField field,\nsuper(field.getType());\nif (!field.isSupported()) {\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
                                    "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
                                    "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.DateTime:withMinuteOfHour(I)Lorg/joda/time/DateTime;",
                                    "method_body": "public DateTime withMinuteOfHour(int minute) {\nreturn withMillis(getChronology().minuteOfHour().set(getMillis(), minute));\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 27,
                    "tests": [
                        {
                            "test_name": "org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455",
                            "test_body": "846: public void testBug2495455() {\n847: PeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n848: .appendLiteral(\"P\")\n849: .appendYears()\n850: .appendSuffix(\"Y\")\n851: .appendMonths()\n852: .appendSuffix(\"M\")\n853: .appendWeeks()\n854: .appendSuffix(\"W\")\n855: .appendDays()\n856: .appendSuffix(\"D\")\n857: .appendSeparatorIfFieldsAfter(\"T\")\n858: .appendHours()\n859: .appendSuffix(\"H\")\n860: .appendMinutes()\n861: .appendSuffix(\"M\")\n862: .appendSecondsWithOptionalMillis()\n863: .appendSuffix(\"S\")\n864: .toFormatter();\n865: PeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n866: .append(ISOPeriodFormat.standard())\n867: .toFormatter();\n868: pfmt1.parsePeriod(\"PT1003199059S\");\n869: pfmt2.parsePeriod(\"PT1003199059S\");\n870: }\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.joda.time.format.FormatUtils:createErrorMessage(Ljava/lang/String;I)Ljava/lang/String;",
                                    "method_body": "static String createErrorMessage(final String text, final int errorPos) {\nint sampleLen = errorPos + 32;\nif (text.length() <= sampleLen + 3) {\nsampleText = text;\nif (errorPos <= 0) {\nif (errorPos >= text.length()) {\nreturn \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.ISOPeriodFormat:standard()Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "public static PeriodFormatter standard() {\nif (cStandard == null) {\ncStandard = new PeriodFormatterBuilder()\nreturn cStandard;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:<init>()V",
                                    "method_body": "public PeriodFormatterBuilder() {\nclear();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter()Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "public PeriodFormatter toFormatter() {\nPeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\niFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\nreturn formatter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:clear()V",
                                    "method_body": "public void clear() {\niMinPrintedDigits = 1;\niPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\niMaxParsedDigits = 10;\niRejectSignedValues = false;\niPrefix = null;\nif (iElementPairs == null) {\niElementPairs = new ArrayList<Object>();\niNotPrinter = false;\niNotParser = false;\niFieldFormatters = new FieldFormatter[10];\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:append(Lorg/joda/time/format/PeriodFormatter;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder append(PeriodFormatter formatter) {\nif (formatter == null) {\nclearPrefix();\nappend0(formatter.getPrinter(), formatter.getParser());\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendLiteral(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendLiteral(String text) {\nif (text == null) {\nclearPrefix();\nLiteral literal = new Literal(text);\nappend0(literal, literal);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendYears()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendYears() {\nappendField(YEARS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMonths()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendMonths() {\nappendField(MONTHS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendWeeks()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendWeeks() {\nappendField(WEEKS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendDays()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendDays() {\nappendField(DAYS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendHours()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendHours() {\nappendField(HOURS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMinutes()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendMinutes() {\nappendField(MINUTES);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSecondsWithOptionalMillis()Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\nappendField(SECONDS_OPTIONAL_MILLIS);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(I)V",
                                    "method_body": "private void appendField(int type) {\nappendField(type, iMinPrintedDigits);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(II)V",
                                    "method_body": "private void appendField(int type, int minPrinted) {\nFieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\nappend0(field, field);\niFieldFormatters[type] = field;\niPrefix = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSuffix(String text) {\nif (text == null) {\nreturn appendSuffix(new SimpleAffix(text));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\nif (iElementPairs.size() > 0) {\noriginalPrinter = iElementPairs.get(iElementPairs.size() - 2);\noriginalParser = iElementPairs.get(iElementPairs.size() - 1);\nif (originalPrinter == null || originalParser == null ||\nclearPrefix();\nFieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\niElementPairs.set(iElementPairs.size() - 2, newField);\niElementPairs.set(iElementPairs.size() - 1, newField);\niFieldFormatters[newField.getFieldType()] = newField;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparatorIfFieldsAfter(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\nreturn appendSeparator(text, text, null, false, true);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparator(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;ZZ)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder appendSeparator(String text, String finalText,\nif (text == null || finalText == null) {\nclearPrefix();\nList<Object> pairs = iElementPairs;\nif (pairs.size() == 0) {\nSeparator lastSeparator = null;\nfor (i=pairs.size(); --i>=0; ) {\nif (pairs.get(i) instanceof Separator) {\ni--;  // element pairs\nif (lastSeparator != null && pairs.size() == 0) {\nObject[] comp = createComposite(pairs);\npairs.clear();\nSeparator separator = new Separator(\npairs.add(separator);\npairs.add(separator);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:clearPrefix()V",
                                    "method_body": "private void clearPrefix() throws IllegalStateException {\nif (iPrefix != null) {\niPrefix = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:append0(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder;",
                                    "method_body": "private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\niElementPairs.add(printer);\niElementPairs.add(parser);\niNotPrinter |= (printer == null);\niNotParser |= (parser == null);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter(Ljava/util/List;ZZ)Lorg/joda/time/format/PeriodFormatter;",
                                    "method_body": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\nif (notPrinter && notParser) {\nint size = elementPairs.size();\nif (size >= 2 && elementPairs.get(0) instanceof Separator) {\nSeparator sep = (Separator) elementPairs.get(0);\nPeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\nsep = sep.finish(f.getPrinter(), f.getParser());\nreturn new PeriodFormatter(sep, sep);\nObject[] comp = createComposite(elementPairs);\nif (notPrinter) {\n} else if (notParser) {\nreturn new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder:createComposite(Ljava/util/List;)[Ljava/lang/Object;",
                                    "method_body": "private static Object[] createComposite(List<Object> elementPairs) {\nswitch (elementPairs.size()) {\nreturn new Object[] {Literal.EMPTY, Literal.EMPTY};\nComposite comp = new Composite(elementPairs);\nreturn new Object[] {comp, comp};\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Literal:<init>(Ljava/lang/String;)V",
                                    "method_body": "Literal(String text) {\niText = text;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(IIIZI[Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
                                    "method_body": "FieldFormatter(int minPrintedDigits, int printZeroSetting,\nPeriodFieldAffix prefix, PeriodFieldAffix suffix) {\niMinPrintedDigits = minPrintedDigits;\niPrintZeroSetting = printZeroSetting;\niMaxParsedDigits = maxParsedDigits;\niRejectSignedValues = rejectSignedValues;\niFieldType = fieldType;\niFieldFormatters = fieldFormatters;\niPrefix = prefix;\niSuffix = suffix;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
                                    "method_body": "FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\niMinPrintedDigits = field.iMinPrintedDigits;\niPrintZeroSetting = field.iPrintZeroSetting;\niMaxParsedDigits = field.iMaxParsedDigits;\niRejectSignedValues = field.iRejectSignedValues;\niFieldType = field.iFieldType;\niFieldFormatters = field.iFieldFormatters;\niPrefix = field.iPrefix;\nif (field.iSuffix != null) {\niSuffix = suffix;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:getFieldType()I",
                                    "method_body": "int getFieldType() {\nreturn iFieldType;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix:<init>(Ljava/lang/String;)V",
                                    "method_body": "int calculatePrintedLength(int value);\nSimpleAffix(String text) {\niText = text;\n}\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
                                    "method_body": "Composite(List<Object> elementPairs) {\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\ndecompose(elementPairs, printerList, parserList);\nif (printerList.size() <= 0) {\niPrinters = printerList.toArray(\nif (parserList.size() <= 0) {\niParsers = parserList.toArray(\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:<init>(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;ZZ)V",
                                    "method_body": "Separator(String text, String finalText, String[] variants,\nboolean useBefore, boolean useAfter) {\niText = text;\niFinalText = finalText;\nif ((finalText == null || text.equals(finalText)) &&\niParsedForms = new String[] {text};\niBeforePrinter = beforePrinter;\niBeforeParser = beforeParser;\niUseBefore = useBefore;\niUseAfter = useAfter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:finish(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder$Separator;",
                                    "method_body": "Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\niAfterPrinter = afterPrinter;\niAfterParser = afterParser;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:<init>(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)V",
                                    "method_body": "public PeriodFormatter(\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niParseType = null;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:getPrinter()Lorg/joda/time/format/PeriodPrinter;",
                                    "method_body": "public PeriodPrinter getPrinter() {\nreturn iPrinter;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:getParser()Lorg/joda/time/format/PeriodParser;",
                                    "method_body": "public PeriodParser getParser() {\nreturn iParser;\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:parsePeriod(Ljava/lang/String;)Lorg/joda/time/Period;",
                                    "method_body": "public Period parsePeriod(String text) {\ncheckParser();\nreturn parseMutablePeriod(text).toPeriod();\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:parseMutablePeriod(Ljava/lang/String;)Lorg/joda/time/MutablePeriod;",
                                    "method_body": "public MutablePeriod parseMutablePeriod(String text) {\ncheckParser();\nMutablePeriod period = new MutablePeriod(0, iParseType);\nint newPos = getParser().parseInto(period, text, 0, iLocale);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn period;\nnewPos = ~newPos;\nthrow new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.format.PeriodFormatter:checkParser()V",
                                    "method_body": "private void checkParser() {\nif (iParser == null) {\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutablePeriod:<init>(JLorg/joda/time/PeriodType;)V",
                                    "method_body": "public MutablePeriod(long duration, PeriodType type) {\nsuper(duration, type, null);\n}"
                                },
                                {
                                    "method_signature": "org.joda.time.MutablePeriod:<init>(Ljava/lang/Object;Lorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
                                    "method_body": "public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\nsuper(period, type, chrono);\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}